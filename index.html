<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Fishing Poker [v3.0.2] - Detail & Economy Polish</title>
    <style>
        /* ================= UI æ ·å¼ä¿æŒ v1.9.9 åŸºç¡€ ================= */
        :root {
            --bg-gradient: radial-gradient(circle at center, #1a202c 0%, #000000 100%);
            --card-width: 60px;
            --card-height: 86px;
            --mini-card-width: 48px;  
            --mini-card-height: 68px;
            
            --gold-color: #ffd700;
            --highlight: #00f2ff;
            --danger: #ff0055;
            --rare: #d580ff;
            --panel-bg: rgba(25, 25, 30, 0.95);
            --modal-bg: linear-gradient(180deg, #37475a 0%, #232d3a 100%);
        }

        @media (min-width: 768px) {
            :root { --card-width: 80px; --card-height: 112px; }
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; font-family: 'Segoe UI', sans-serif; }
        body { background: var(--bg-gradient); color: #fff; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }

        /* Splash Screen */
        #splash-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 300; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 1.5s ease-in-out; pointer-events: none; }
        .splash-logo { width: 120px; height: 120px; fill: #fff; margin-bottom: 20px; filter: drop-shadow(0 0 10px rgba(255,255,255,0.5)); }
        .splash-text { font-family: 'Segoe UI Light', sans-serif; font-weight: 100; font-size: 24px; letter-spacing: 8px; color: #fff; opacity: 0.8; }
        .fade-out { opacity: 0 !important; }

        /* Lobby */
        #lobby-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(180deg, #050a14 0%, #000000 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; overflow: hidden; transition: opacity 0.5s; }
        .waves-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 40vh; pointer-events: none; z-index: 1; opacity: 0.3; }
        .waves { width: 100%; height: 100%; min-height: 100px; max-height: 250px; }
        .parallax > use { animation: move-wave 35s cubic-bezier(.55,.5,.45,.5) infinite; }
        .parallax > use:nth-child(1) { animation-duration: 45s; fill: rgba(0, 50, 100, 0.3); }
        .parallax > use:nth-child(2) { animation-duration: 30s; fill: rgba(0, 80, 150, 0.2); }
        .parallax > use:nth-child(3) { animation-duration: 20s; fill: rgba(0, 100, 200, 0.1); }
        @keyframes move-wave { 0% { transform: translate3d(-90px, 0, 0); } 100% { transform: translate3d(85px, 0, 0); } }
        .story-scroll { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; display: flex; justify-content: center; mask-image: linear-gradient(to bottom, transparent 10%, black 40%, black 60%, transparent 90%); -webkit-mask-image: linear-gradient(to bottom, transparent 10%, black 40%, black 60%, transparent 90%); }
        .story-content { width: 600px; color: rgba(220, 220, 220, 0.3); font-size: 16px; line-height: 2.2; text-align: center; font-family: 'Georgia', serif; font-style: italic; animation: scrollText 45s linear infinite; animation-delay: 2s; transform: translateY(100vh); }
        @keyframes scrollText { 0% { transform: translateY(100vh); } 100% { transform: translateY(-120%); } }
        .lobby-content { text-align: center; z-index: 10; position: relative; }
        .lobby-title-main { font-family: 'YouYuan', 'Microsoft YaHei', sans-serif; font-size: 64px; font-weight: 300; color: #fff; text-shadow: 0 0 15px var(--highlight); margin-bottom: 0; line-height: 1; letter-spacing: 5px; }
        .lobby-title-sub { font-family: 'YouYuan', 'Microsoft YaHei', sans-serif; font-size: 32px; font-weight: 100; color: var(--highlight); text-shadow: 0 0 10px rgba(0, 242, 255, 0.5); margin-top: 15px; letter-spacing: 8px; margin-bottom: 60px; }
        .btn-lobby { font-size: 20px; padding: 16px 60px; width: auto; background: linear-gradient(90deg, var(--highlight), #0099cc); color: #000; font-weight: 800; border:none; border-radius: 50px; box-shadow: 0 0 25px rgba(0, 242, 255, 0.4); cursor: pointer; transition: 0.3s; letter-spacing: 2px; }
        .btn-lobby:hover { transform: scale(1.05) translateY(-2px); box-shadow: 0 0 40px var(--highlight); }
        
        /* Header */
        header { height: 60px; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; padding: 0 20px; background: rgba(0,0,0,0.9); border-bottom: 1px solid #333; z-index: 201; position:relative; transition: transform 0.3s ease-in-out; }
        body.overlay-active header { display: none; }
        .header-left { display: flex; flex-direction: column; transition: opacity 0.3s; }
        .level-id { font-size: 20px; color: var(--highlight); font-weight: 800; letter-spacing: 1px; }
        .level-goal { font-size: 12px; color: #bbb; margin-top: 2px; }
        .lobby-hide { opacity: 0; pointer-events: none; }

        /* Unified Header Buttons */
        .header-center { display: flex; gap: 12px; align-items: center; position: absolute; left: 50%; transform: translateX(-50%); }
        .icon-btn { width: 28px; height: 28px; background: #333; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; border: 1px solid #555; transition: 0.2s; color: #aaa; }
        .icon-btn:hover { border-color: var(--highlight); color: var(--highlight); box-shadow: 0 0 10px rgba(0, 242, 255, 0.2); }
        .icon-btn.active { color: var(--highlight); border-color: var(--highlight); box-shadow: 0 0 5px rgba(0, 242, 255, 0.3); animation: pulse-audio 2s infinite; }
        .icon-btn svg { width: 14px; height: 14px; fill: currentColor; }
        @keyframes pulse-audio { 0% { box-shadow: 0 0 5px rgba(0, 242, 255, 0.3); } 50% { box-shadow: 0 0 15px rgba(0, 242, 255, 0.5); } 100% { box-shadow: 0 0 5px rgba(0, 242, 255, 0.3); } }

        .header-right { display: flex; gap: 15px; align-items: center; transition: opacity 0.3s; }
        .passive-dock { display: flex; gap: 5px; max-width: 220px; overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
        .passive-dock::-webkit-scrollbar { display: none; }
        .passive-icon { width: 28px; height: 28px; background: #2d3748; border: 1px solid var(--rare); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 16px; cursor: help; color: var(--rare); position: relative; flex-shrink: 0; }
        
        #global-tooltip {
            position: fixed; background: rgba(0,0,0,0.95); padding: 10px 15px; font-size: 12px; line-height: 1.5; border: 1px solid #666; border-radius: 6px; color: #fff; box-shadow: 0 5px 20px rgba(0,0,0,0.9); z-index: 9999; pointer-events: none; display: none; max-width: 220px; white-space: pre-wrap;
        }

        .gold-container { display: flex; align-items: center; gap: 10px; }
        .bet-info { font-size: 12px; color: #ff9f43; font-weight: bold; animation: pulse 1s infinite; display: none; }
        .gold-pill { color: var(--gold-color); font-weight: bold; font-size: 16px; background: rgba(255, 215, 0, 0.1); padding: 5px 12px; border-radius: 4px; border: 1px solid rgba(255, 215, 0, 0.3); }
        .gold-val { color: var(--gold-color); font-weight: bold; }
        
        /* Main Layout */
        #main-stage { flex: 1; display: flex; padding: 20px; gap: 20px; overflow: hidden; align-items: stretch; }
        .panel { background: var(--panel-bg); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; display: flex; flex-direction: column; align-items: center; padding: 15px; position: relative; }
        .panel-title { font-size: 12px; text-transform: uppercase; color: #888; letter-spacing: 1px; width: 100%; text-align: center; margin-bottom: 10px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        #left-panel { flex: 0 0 220px; justify-content: flex-start; position: relative;}
        .avatar { width: 70px; height: 70px; border-radius: 50%; border: 3px solid #555; background: #222 center/cover; margin-bottom: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.5); transition: background-image 0.5s;}
        
        .opp-speech { 
            position: absolute; left: 170px; top: 70px; width: 180px; 
            background: rgba(0,0,0,0.9); border: 1px solid var(--highlight); border-radius: 10px; 
            padding: 10px; color: #fff; font-size: 12px; line-height: 1.4; 
            opacity: 0; pointer-events: none; z-index: 50; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.8); transition: opacity 0.5s; 
        }
        .opp-speech::before { content: ''; position: absolute; top: 15px; left: -8px; width: 0; height: 0; border-top: 8px solid transparent; border-bottom: 8px solid transparent; border-right: 8px solid var(--highlight); }

        .opp-hand-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-top: 10px; }
        #center-panel { flex: 1; justify-content: space-between; }
        .baits-container { display: flex; flex-direction: column; gap: 20px; width: 100%; align-items: center; justify-content: center; flex: 1; }
        .bait-row { display: flex; gap: 15px; align-items: center; position: relative; justify-content: center; min-height: 90px; width: 100%; }
        .bait-label { position: static; width: auto; min-width: 60px; font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; text-align: right; margin-right: 10px; display: flex; flex-direction: column; justify-content: center; }
        .slot-placeholder { width: var(--card-width); height: var(--card-height); border: 2px dashed rgba(255,255,255,0.15); border-radius: 6px; background: rgba(0,0,0,0.2); }
        #player-hand-area { margin-top: auto; width: 100%; display: flex; justify-content: center; padding-top: 20px; border-top: 1px solid #444; height: 130px; }
        #hand-container { display: flex; gap: 8px; align-items: flex-end; }
        #right-panel { flex: 0 0 240px; justify-content: space-between; padding-bottom: calc(15px + env(safe-area-inset-bottom)); }
        .action-area { width: 100%; display: flex; flex-direction: column; gap: 10px; flex: 1; }
        #skill-dock { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 20px; padding-top: 10px; border-top: 1px solid #444; }
        
        .card-deal-anim { animation: cardDeal 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) backwards; }
        @keyframes cardDeal { 0% { transform: translateY(-50px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }

        .card { background: #f0f0f0; border-radius: 6px; position: relative; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); width: var(--card-width); height: var(--card-height); overflow: hidden; }
        .card.mini { width: var(--mini-card-width); height: var(--mini-card-height); font-size: 0.8em;}
        .card.red { color: #e74c3c; } .card.black { color: #2c3e50; }
        .card-rank { position: absolute; top: 4px; left: 6px; font-size: 1.4em; font-weight: 800; line-height: 1; }
        .card-suit { position: absolute; top: 55%; left: 50%; transform: translate(-50%, -50%); font-size: 2.5em; line-height: 1; }
        .card-back { background: #34495e; border: 2px solid #7f8c8d; display: flex; align-items: center; justify-content: center; }
        .card-back::after { content: ''; width: 70%; height: 70%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" fill="none" stroke="%2394a3b8" stroke-width="5"><path d="M20,30 L50,80 L80,30 L90,10 L50,30 L10,10 Z" /></svg>'); background-repeat: no-repeat; background-position: center; opacity: 0.3; }

        .card:hover { transform: translateY(-5px); z-index: 10; }
        .card.selected { transform: translateY(-15px); box-shadow: 0 0 15px var(--highlight); border: 2px solid var(--highlight); z-index: 10; }
        .card.opp-selected { transform: translateY(-15px); box-shadow: 0 0 15px var(--danger); border: 2px solid var(--danger); z-index: 10; }
        .badge-bait { position: absolute; top:0; right:0; background:#333; color:#fff; font-size:9px; padding:1px 3px; z-index:2;}
        
        .btn { background: linear-gradient(145deg, #2c3e50, #1a252f); border: 1px solid #4a5c6a; color: #fff; padding: 12px 5px; border-radius: 4px; cursor: pointer; transition: 0.2s; font-size: 13px; text-align: center; position: relative; width: 100%; box-shadow: 0 2px 5px rgba(0,0,0,0.3); user-select: none; -webkit-tap-highlight-color: transparent; }
        .btn:active { transform: scale(0.95); }
        .btn:hover:not(:disabled) { border-color: var(--highlight); box-shadow: 0 0 15px rgba(0, 242, 255, 0.5); background: #34495e; }
        .btn-primary { background: linear-gradient(145deg, #2980b9, #2c3e50); border: 1px solid #3498db; }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; transform: none; }
        .btn-desc { display: block; font-size: 10px; opacity: 0.7; margin-top: 2px; }
        
        .skill-item { aspect-ratio: 3/4; background: #34495e; border-radius: 4px; border: 1px solid #566573; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; position: relative; transition: 0.2s; }
        .skill-item:hover:not(.disabled) { border-color: var(--highlight); box-shadow: 0 0 10px var(--highlight); }
        .skill-item.disabled { filter: grayscale(1); opacity: 0.3; cursor: default; }
        .skill-count { position: absolute; bottom: 2px; right: 2px; font-size: 9px; background: #000; padding: 1px 3px; border-radius: 3px; }
        [data-desc]:hover::after { content: attr(data-desc); position: absolute; bottom: 110%; right: 0; background: rgba(0,0,0,0.95); padding: 8px; font-size: 11px; width: 140px; z-index: 100; color: #fff; border-radius: 4px; border: 1px solid #555; pointer-events: none; box-shadow: 0 5px 15px rgba(0,0,0,0.8); }
        
        .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; z-index: 400; opacity: 0; pointer-events: none; transition: 0.3s; }
        .overlay.visible { opacity: 1; pointer-events: all; }
        
        .settle-modal { width: 90%; max-width: 750px; background: var(--modal-bg); border-radius: 12px; box-shadow: 0 0 50px rgba(0,0,0,0.8); border: 1px solid #4a5c6a; overflow: hidden; display: flex; flex-direction: column; max-height: 90vh; }
        .settle-header { background: rgba(0,0,0,0.3); padding: 8px 15px; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center; color: #fff; flex-shrink: 0; }
        .multiplier-bar { display: flex; gap: 10px; align-items: center; font-family: monospace; font-size: 16px; color: var(--gold-color);}
        
        .settle-content { display: flex; min-height: 200px; flex: 1; overflow-y: auto; }
        .settle-left { width: 35%; background: rgba(0,0,0,0.2); padding: 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; border-right: 1px solid rgba(255,255,255,0.1); gap: 10px; }
        .settle-right { width: 65%; padding: 20px; display: flex; flex-direction: column; justify-content: center; gap: 15px; }
        
        .result-badge { background: #333; padding: 2px 10px; font-size: 12px; color: #aaa; margin-bottom: 5px; }
        .win-title-tag { align-self: center; background: linear-gradient(90deg, #d35400, #e67e22); color: white; font-weight: bold; font-size: 20px; padding: 5px 25px; border-radius: 4px; box-shadow: 0 0 15px rgba(230, 126, 34, 0.6); margin-bottom: 10px; }
        .lose-title-tag { align-self: center; background: #555; color: #aaa; font-weight: bold; font-size: 20px; padding: 5px 25px; border-radius: 4px; margin-bottom: 10px; }
        .cards-display-row { display: flex; justify-content: center; gap: 8px; margin: 5px 0; flex-wrap: wrap; }
        .detail-row { display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 4px; font-size: 14px; }
        .detail-sub { font-size: 12px; color: #888; display: flex; gap: 10px; align-items: center;}
        
        .settle-footer { padding: 15px; background: rgba(0,0,0,0.4); text-align: center; border-top: 1px solid rgba(255,255,255,0.1); flex-shrink: 0; }
        .tags-container { margin-top: 5px; display: flex; flex-direction: row; flex-wrap: wrap; justify-content: flex-start; gap: 8px; }
        
        .score-tag { background: #333; border: 1px solid #555; padding: 4px 12px; border-radius: 20px; font-size: 12px; display: flex; align-items: center; gap: 5px; }
        .tag-win { background: linear-gradient(90deg, #f1c40f, #f39c12); color: #fff; font-weight: bold; border: none; }
        .tag-fish { border:1px solid var(--highlight); color: #fff; font-weight: bold; }
        .tag-skill { border:1px solid var(--rare); color: var(--rare); }
        
        .reward-container { display: flex; gap: 30px; justify-content: center; flex-wrap: wrap; }
        .reward-card { width: 180px; height: 260px; background: #2d3748; border: 2px solid #4a5568; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; padding: 20px; text-align: center; transition: 0.3s; box-shadow: 0 4px 15px rgba(0,0,0,0.5); position:relative;}
        .reward-card:hover { transform: scale(1.05); border-color: var(--rare); box-shadow: 0 0 25px rgba(213, 128, 255, 0.4); }
        
        .info-panel { background: #1a1a1a; border: 1px solid #555; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; color: #ddd; box-shadow: 0 0 30px black; }
        .info-title { color: var(--highlight); margin-bottom: 5px; text-align: center; font-size: 18px; font-weight: bold; }
        .info-desc { font-size: 12px; color: #888; text-align: center; margin-bottom: 20px; }
        .info-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #333; font-size: 14px; }
        .info-row span { flex: 1; text-align: center; }
        .info-row span:first-child { text-align: left; }
        .info-row span:last-child { text-align: right; }
        .val-highlight { color: var(--gold-color); font-weight: bold; text-shadow: 0 0 5px gold; }
        .msg-screen-content { text-align: center; color: #fff; }
        .msg-title { font-size: 40px; font-weight: 800; margin-bottom: 20px; color: var(--danger); text-shadow: 0 0 20px rgba(0,0,0,0.8); }
        .msg-subtitle { font-size: 18px; color: #ccc; margin-bottom: 40px; }
        .msg-title.success { color: var(--gold-color); }
        
        .letter-modal { width: 95%; max-width: 800px; background: rgba(18, 22, 30, 0.98); border: 2px solid var(--gold-color); border-radius: 12px; padding: 30px; box-shadow: 0 0 50px rgba(0,0,0,0.8), inset 0 0 100px rgba(0,0,0,0.8); font-family: 'Times New Roman', serif; color: #d1d5db; line-height: 1.8; max-height: 90vh; overflow-y: auto; display: flex; flex-direction: column; position: relative; }
        .letter-modal::before { content: 'âœ‰'; position: absolute; top: 15px; left: 20px; font-size: 24px; color: var(--gold-color); opacity: 0.5; }
        .letter-header { font-size: 32px; font-weight: bold; color: var(--gold-color); margin-bottom: 25px; text-align: center; border-bottom: 1px solid rgba(255, 215, 0, 0.2); padding-bottom: 15px; font-family: 'YouYuan', serif; }
        .letter-body { font-size: 15px; margin-bottom: 30px; text-align: justify; }
        .letter-body b { color: var(--highlight); }
        .letter-footer { display: flex; justify-content: center; }
        .hl-txt { color: var(--highlight); font-weight: bold; }
        .gold-txt { color: var(--gold-color); font-weight: bold; }
        .info-footer { margin-top: 15px; font-size: 12px; color: #666; line-height: 1.5; border-top: 1px solid #444; padding-top: 10px; }

        @media (max-width: 768px) {
            .settle-modal { width: 95%; max-width: 400px; }
            .settle-content { flex-direction: column; }
            .settle-left, .settle-right { width: 100%; border-right: none; border-bottom: 1px solid rgba(255,255,255,0.1); padding: 15px; }
            .settle-right { border-bottom: none; }
            .win-title-tag, .lose-title-tag { font-size: 18px; padding: 4px 20px; }
            .cards-display-row { transform: scale(0.9); margin: 0; }
        }

        @media screen and (max-height: 600px) and (orientation: landscape) {
            :root { --card-width: 40px; --card-height: 56px; --mini-card-width: 32px; --mini-card-height: 44px; }
            .card.mini .card-rank { font-size: 10px; top: 1px; left: 2px; }
            .card.mini .card-suit { font-size: 1.4em; top: 60%; } 
            .card-rank { font-size: 11px; top: 1px; left: 3px; }
            .card-suit { font-size: 1.8em; top: 58%; }
            .info-panel { width: 90%; max-height: 85vh; overflow-y: auto; font-size: 10px; padding: 10px; }
            .lobby-title-main { font-size: 40px; letter-spacing: 2px; }
            .lobby-title-sub { font-size: 20px; margin-bottom: 20px; letter-spacing: 2px; }
            .btn-lobby { font-size: 16px; padding: 10px 30px; }
            .story-content { font-size: 14px; width: 80%; }
            header { height: 40px; padding: 0 10px; }
            .level-id { font-size: 16px; }
            .level-goal { font-size: 10px; }
            .info-btn { padding: 4px 8px; font-size: 10px; }
            .gold-pill { font-size: 12px; padding: 3px 8px; }
            #main-stage { padding: 5px; gap: 8px; }
            #left-panel { flex: 0 0 130px; padding: 8px; }
            .avatar { width: 50px; height: 50px; margin-bottom: 5px; }
            .opp-hand-grid { gap: 4px; }
            .panel-title { font-size: 10px; margin-bottom: 5px; padding-bottom: 2px; }
            .opp-speech { left: 110px; top: 25px; width: 140px; font-size: 10px; padding: 6px; border-radius: 8px; }
            #right-panel { flex: 0 0 160px; padding: 8px; padding-bottom: calc(8px + env(safe-area-inset-bottom)); }
            .btn { padding: 8px 2px; font-size: 10px; }
            #skill-dock { margin-top: 5px; padding-top: 5px; gap: 4px; }
            .skill-item div:first-child { font-size: 16px; } 
            .skill-item div:nth-child(2) { font-size: 9px; transform: scale(0.9); }
            #center-panel { padding: 5px; }
            .baits-container { gap: 5px; }
            .bait-row { min-height: 60px; gap: 8px; }
            .bait-label { min-width: 40px; font-size: 10px; margin-right: 5px; }
            .slot-placeholder { border-width: 1px; border-radius: 4px; }
            #player-hand-area { height: 70px; padding-top: 10px; }
            .settle-modal { max-height: 95vh; overflow-y: auto; }
            .settle-header { padding: 8px 15px; font-size: 16px; }
            .settle-content { flex-direction: row; min-height: auto; }
            .settle-left { width: 30%; padding: 10px; gap: 5px; }
            .settle-right { width: 70%; padding: 10px; gap: 10px; }
            .win-title-tag, .lose-title-tag { font-size: 16px; padding: 4px 15px; }
            .detail-row { padding: 8px; }
            .reward-container { gap: 10px; }
            .reward-card { width: 130px; height: 180px; padding: 10px; }
            .reward-card div:first-child { font-size: 30px; margin-bottom: 5px; } 
            .msg-title { font-size: 28px; }
            .msg-subtitle { font-size: 14px; margin-bottom: 20px; }
            .letter-modal { width: 95%; padding: 20px; }
            .letter-header { font-size: 24px; margin-bottom: 15px; }
            .letter-body { font-size: 12px; margin-bottom: 20px; line-height: 1.6; }
        }
    </style>
</head>
<body>

<div id="splash-screen">
    <svg class="splash-logo" viewBox="0 0 100 100">
        <path d="M20,80 Q35,60 50,80 T80,80" fill="none" stroke="white" stroke-width="8" stroke-linecap="round" />
        <path d="M20,50 Q35,30 50,50 T80,50" fill="none" stroke="white" stroke-width="8" stroke-linecap="round" />
        <path d="M20,20 Q35,0 50,20 T80,20" fill="none" stroke="white" stroke-width="8" stroke-linecap="round" />
    </svg>
    <div class="splash-text">FISHER GAME</div>
</div>
<!-- Global Tooltip for Passive Icons -->
<div id="global-tooltip"></div>

<div id="lobby-screen">
    <div class="waves-container">
        <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
            <defs> <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" /> </defs>
            <g class="parallax">
                <use xlink:href="#gentle-wave" x="48" y="0" />
                <use xlink:href="#gentle-wave" x="48" y="3" />
                <use xlink:href="#gentle-wave" x="48" y="5" />
            </g>
        </svg>
    </div>
    <div class="story-scroll">
        <div class="story-content">
            çå¼€çœ¼ï¼Œå·²ç»åˆ°äº†æ¸¯å£<br>
            çˆ·çˆ·åœ¨æˆ‘è¢«èµ¶ä¸‹èˆ¹å‰ï¼Œå¡ç»™æˆ‘äº†ä¸€ä¸ªå®ç›’ï¼Œä¸€ä¸ªé”¦å›Šï¼Œè®©æˆ‘ä¸€å®šå¸¦å¥½ï¼Œå®ƒä¼šç»™æˆ‘å¥½è¿<br>
            å¥½å¤å¤çš„è¢‹å­ï¼Œé‡Œé¢è£…ç€ä¸€å¼ å¡ç‰‡ï¼Œçœ‹èµ·æ¥ï¼Œæœ‰äº›å¹´å¤´ã€‚<br>
            çˆ·çˆ·è¯´ï¼Œå®çŸ³æ— è®ºå¦‚ä½•åˆ«æ‹¿å‡ºæ¥ï¼Œåªç®¡å¸¦ç€å°±å¥½ã€‚è€Œé•œå›Šï¼Œåœ¨å±æœºæ—¶åˆ»ï¼Œå¯ä»¥å¸®æˆ‘ã€‚<br>
            æˆ‘ç‚¹äº†ç‚¹å¤´ï¼Œåˆçœ‹äº†çœ¼å®ç›’ï¼Œé‡Œé¢è£…ç€çš„å®çŸ³äº®ç€ç´«è‰²ï¼Œå…‰èŠ’è€€çœ¼ï¼Œæˆ‘ç«‹é©¬åˆä¸Šå®ç›’ã€‚<br>
            åœ¨å–‡å­çš„å‚¬ä¿ƒä¸‹ï¼Œéšç€äººç¾¤èµ°ä¸‹èˆ¹ã€‚<br>
            è¿™é‡Œæ˜¯ä»–ä»¬å£ä¸­è¯´çš„ï¼Œå¾é€”é‡Œçš„ç¬¬ä¸€å²›ï¼šç‹ç‹¸å²›ï¼Œéš¾åº¦ç³»æ•°è¾¾4æ˜ŸåŠï¼›éƒ½æ²¡åˆ°åŠæ ¼çš„6æ˜Ÿï¼Œ<br>
            å´æ˜¯è®©æœ€å¤šäººå€’ä¸‹çš„åœ°æ–¹ï¼Œç”šè‡³æœ‰ä¼ è¨€è¿™é‡Œç»å¸¸æœ‰äººå¤±è¸ªï¼Œå¿˜äº†å›å®¶çš„è·¯ã€‚<br>
            è°çŸ¥é“å‘¢ï¼Œæˆ–è®¸æˆä¸ºå¤§äººçš„è·¯ä¸Šï¼Œéƒ½æ˜¯éš¾å…çš„ï¼Ÿæˆ‘ä¸çŸ¥é“ã€‚<br>
            å»äº†å†è¯´å§ã€‚ä½†ä»–ä»¬ä»€ä¹ˆéƒ½ä¸è¯´ï¼Œè¦æ€ä¹ˆæ‰èƒ½æ‹¿åˆ°ç‹ç‹¸å²›çš„é€šå…³ç›–ç« å‘¢ï¼Ÿ<br>
            â€œä¸‹èˆ¹å•¦ï¼Œä¸‹èˆ¹å•¦ã€‚â€<br>
            â€œè¦æ‹¿åˆ°é€šå…³ç›–ç« ï¼Œå¾—é ä½ ä»¬è‡ªå·±ã€‚14å¤©åï¼Œè¿˜æ˜¯åœ¨è¿™é‡Œï¼Œæ‹¿åˆ°ç›–ç« è€…ï¼Œå³å°†å‰å¾€ä¸‹ä¸€å²›ã€‚<br>
            å¤±è´¥è€…ï¼Œé£è¿”å›æ‘ã€‚â€œ<br>
            â€œå»å§ã€‚â€
        </div>
    </div>
    <div class="lobby-content">
        <div class="lobby-title-main">é’“é±¼ç‰Œ</div>
        <div class="lobby-title-sub">æ— å°½å¡”æ¥¼</div>
        <button class="btn btn-lobby" onclick="game.startGame()">å¼€å§‹æŒ‘æˆ˜</button>
    </div>
    <div style="position: absolute; bottom: 20px; right: 20px; color: rgba(255,255,255,0.3); font-family: monospace;">v3.0.2</div>
</div>

<header>
    <div class="header-left lobby-hide" id="header-left-col">
        <div class="level-id" id="level-id">FLOOR 1-1</div>
        <div class="level-goal"><span>å…³å¡ç›®æ ‡ï¼š</span><span id="level-desc" style="color:#ddd">åŠ è½½ä¸­...</span></div>
    </div>
    <div class="header-center">
        <!-- Info Btn (Poker Card) -->
        <div class="icon-btn" onclick="game.toggleInfo()" title="ç‰Œå‹è¯´æ˜">
            <svg viewBox="0 0 24 24"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14h-2v-4h2v4zm0-6h-2V7h2v4z"/></svg>
        </div>
        <!-- Audio Btn -->
        <div class="icon-btn" id="audio-toggle" onclick="game.toggleAudio()" title="åˆ‡æ¢æ°›å›´éŸ³æ•ˆ">
            <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
        </div>
        <!-- Fullscreen Btn -->
        <div class="icon-btn" id="fs-toggle" onclick="game.toggleFullscreen()" title="å…¨å±åˆ‡æ¢">
            <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
        </div>
    </div>
    <div class="header-right lobby-hide" id="header-right-col">
        <div class="passive-dock" id="passive-list"></div>
        <div class="gold-container">
            <span class="bet-info" id="bet-display">ä¸‹æ³¨: 0</span>
            <div class="gold-pill">ğŸ’° <span id="gold-display">0</span></div>
        </div>
    </div>
</header>

<div id="main-stage">
    <div class="panel" id="left-panel">
        <div class="panel-title" id="opp-name">å¯¹æ‰‹</div>
        <div class="avatar" id="opp-avatar"></div>
        <div class="opp-speech" id="opp-speech"></div>
        <div style="font-size:12px; color:#aaa; margin-bottom:5px;">æ‰‹ç‰Œ: <span id="opp-count">7</span></div>
        <div class="opp-hand-grid" id="opp-hand-container"></div>
    </div>
    <div class="panel" id="center-panel">
        <div class="panel-title">å…¬å…±ç‰Œæ¡Œ</div>
        <div class="baits-container">
            <div class="bait-row"><div class="bait-label">Ta çš„<br>è¯±é¥µ</div><div id="opp-bait-container" style="display:flex; gap:10px"></div></div>
            <div style="height:20px;"></div>
            <div class="bait-row"><div class="bait-label">æˆ‘çš„<br>è¯±é¥µ</div><div id="my-bait-container" style="display:flex; gap:10px"></div></div>
        </div>
        <div id="player-hand-area"><div id="hand-container"></div></div>
    </div>
    <div class="panel" id="right-panel">
        <div class="panel-title">æ§åˆ¶å°</div>
        <div class="action-area">
            <div id="phase-tip" style="text-align:center; color:#888; font-size:12px; margin-bottom:10px;">å‡†å¤‡ä¸­...</div>
            <button id="btn-bait" class="btn btn-primary" style="display:none">æ”¾å…¥è¯±é¥µ (0/2)</button>
            <div id="play-group" style="display:none; flex-direction:column; gap:10px;">
                <button id="btn-combo-opp" class="btn" disabled><span>å’Œ TA è¯±é¥µç»„åˆ</span></button>
                <button id="btn-combo-mine" class="btn" disabled><span>å’Œ æˆ‘çš„ è¯±é¥µç»„åˆ</span></button>
                <div style="text-align:center;font-size:10px;">OR</div>
                <button id="btn-play-hand" class="btn" disabled><span>ç›´æ¥å‡º 5 å¼ æ‰‹ç‰Œ</span></button>
            </div>
            <div id="skill-confirm-group" style="display:none; flex-direction:column; gap:5px;">
                <div id="skill-desc-text" style="font-size:11px; color:var(--rare); text-align:center; margin-bottom:5px;"></div>
                <button id="btn-skill-ok" class="btn btn-primary" style="background:var(--rare)">ç¡®è®¤æ–½æ³•</button>
                <button id="btn-skill-no" class="btn">å–æ¶ˆ</button>
            </div>
            <div id="bet-panel" style="display:none; flex-direction:column; gap:8px;">
                <div style="text-align:center; color:gold;">å¹»æ³¨: é€‰æ‹©ä¸‹æ³¨é¢</div>
                <button class="btn" id="bet-btn-1" onclick="game.placeBet(0)">ä¸‹æ³¨ 30%</button>
                <button class="btn" id="bet-btn-2" onclick="game.placeBet(1)">ä¸‹æ³¨ 50%</button>
                <button class="btn" onclick="game.cancelSkill()">å–æ¶ˆ</button>
            </div>
        </div>
        <div style="width:100%; border-top:1px solid #444; padding-top:10px; margin-top:20px;">
            <div class="panel-title" style="border:none; margin:0;">æŠ€èƒ½</div>
            <div id="skill-dock"></div>
        </div>
    </div>
</div>

<div id="overlay-screen" class="overlay"></div>
<div id="info-screen" class="overlay" onclick="game.toggleInfo()">
    <div class="info-panel" onclick="event.stopPropagation()">
        <h3 style="color:var(--highlight); margin-bottom:15px; text-align:center;">ç‰Œå‹è¯´æ˜</h3>
        <div id="info-content"></div>
        <div class="info-footer">
            ç‰Œå‹ã€èŠ±è‰²ã€ç‚¹æ•°å¤§å°è¯´æ˜ï¼š<br>
            åŒèŠ±é¡º > å››ç‚¸ > è‘«èŠ¦ > åŒèŠ± > é¡ºå­ > ä¸‰æ¡ > ä¸¤å¯¹ > å•ç‰Œ<br>
            èŠ±è‰²å¤§å°ï¼šé»‘æ¡ƒ > çº¢å¿ƒ > æ–¹å— > æ¢…èŠ±<br>
            ç‚¹æ•°å¤§å°ï¼šA > K > Q > J > 10 > 9 > 8 > 7 > 6 > 5 > 4 > 3 > 2
            <br><span style="color:var(--gold-color)">æ¯å±€è·å¾—é‡‘å¸ï¼šä¸ºæœ¬å±€ç‰Œå‹å¯¹åº”é‡‘å¸æ•°çš„ 10%</span>
        </div>
    </div>
</div>

<div id="tutorial-screen" class="overlay">
    <div class="letter-modal">
        <div class="letter-header">å†™ç»™å†’é™©è€…çš„ä¿¡ï¼</div>
        <div class="letter-body">
            å†’é™©è€…ï¼š<br>
            æ¬¢è¿æ¥åˆ°ç‹ç‹¸å²›ï¼Œè¿™é‡Œå……æ»¡äº†æœºé‡ï¼Œä¹Ÿå¤„å¤„æ˜¯å±é™©ï¼Œä¸è¦å¤ªç›¸ä¿¡çœ¼å‰çš„äº‹ç‰©ã€‚æƒ³è¦æ‹¿åˆ°å¾½ç« ï¼Ÿæ— å°½å¡”æ¥¼å°±åœ¨å‰æ–¹ï¼Œä½ å»ä¾¿æ˜¯ï¼ä½†è¦æ³¨æ„ï¼Œç•™å¿ƒè§‚å¯Ÿæ¯ä¸€å±‚æŒ‘æˆ˜ç›®æ ‡ï¼Œåˆ«å¤§æ„ï¼<br>
            <b class="hl-txt">ã€å…³å¡ç›®æ ‡ã€‘</b>æ˜¯é€šå…³çš„é‡ç‚¹ï¼Œåœ¨é¡¶éƒ¨æ å·¦ä¾§å¯ä»¥æŸ¥çœ‹ã€‚<br>
            <b class="hl-txt">ã€æ¸¸æˆè§„åˆ™ã€‘</b>æ¯äºº 7 å¼ æ‰‹ç‰Œï¼Œæ”¾ 2 å¼ è¯±é¥µç‰Œï¼Œæ¥ç€æ‰‹ä¸­çš„ 5 å¼ æ‰‹ç‰Œå¯ä»¥æ‹¿å‡º 3 å¼ ä¸åŒæ–¹æ”¾ç½®çš„ 2 å¼ è¯±é¥µç‰Œè¿›è¡Œç»„åˆæˆæœ€ç»ˆçš„ 5 å¼ ç‰Œï¼Œä¹Ÿå¯ä»¥ç›´æ¥å‡ºæ‰‹ä¸­çš„ 5 å¼ ç‰Œï¼›<br>
            <b class="hl-txt">ã€å¯¹å±€è¯´æ˜ã€‘</b>ç‰Œå‹åˆ†åŒèŠ±é¡º>å››ç‚¸>è‘«èŠ¦>åŒèŠ±>é¡ºå­>ä¸‰æ¡>ä¸¤å¯¹>å•ç‰Œ ï¼›ä¸åŒç‰Œå‹è·å¾—çš„é‡‘å¸ä¸åŒï¼Œå¯æŸ¥çœ‹ç‰Œå‹è¯´æ˜ï¼›<br>
            <b class="hl-txt">ã€æ¸¸ç©æŠ€å·§ã€‘</b>å…³å¡ä¸­æ”¯æŒä½¿ç”¨é“å…·æŠ€èƒ½ï¼Œå¸®åŠ©ä½ é¡ºåˆ©é€šå…³ï¼<br>
            ç¥ä½ å¥½è¿ï¼è‹¥èƒ½é¡ºåˆ©ç™»ä¸Šæ— å°½å¡”æ¥¼ 8 å±‚ï¼Œä½ ä¼šå†çœ‹åˆ°æˆ‘çš„ï¼Œã€ç‹ç‹¸å¾½ç« ã€‘ç­‰ç€ä½ ï¼
        </div>
        <div class="letter-footer">
            <button class="btn btn-primary" style="width:200px; padding:15px;" onclick="game.enterLevelOne()">è¿›å…¥ç¬¬ 1 å±‚</button>
        </div>
    </div>
</div>

<script>
// =================== éŸ³é¢‘å¼•æ“ (Web Audio API) ===================
class AtmosphereAudio {
    constructor() {
        this.ctx = null;
        this.masterGain = null;
        this.bgmGain = null;
        this.sfxGain = null;
        this.isPlaying = false;
        this.oceanNode = null;
        this.synthInterval = null;
        this.notes = [138.59, 164.81, 185.00, 207.65, 246.94];
    }

    init() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.5;
            this.masterGain.connect(this.ctx.destination);

            this.bgmGain = this.ctx.createGain();
            this.bgmGain.gain.value = 1.0;
            this.bgmGain.connect(this.masterGain);

            this.sfxGain = this.ctx.createGain();
            this.sfxGain.gain.value = 1.0;
            this.sfxGain.connect(this.masterGain);
        }
    }

    createPinkNoise() {
        const bufferSize = 2 * this.ctx.sampleRate;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const output = buffer.getChannelData(0);
        let b0, b1, b2, b3, b4, b5, b6;
        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
        for (let i = 0; i < bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            output[i] *= 0.11; 
            b6 = white * 0.115926;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        noise.loop = true;
        return noise;
    }

    startOcean() {
        const noise = this.createPinkNoise();
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        
        const lfo = this.ctx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 0.15;
        const lfoGain = this.ctx.createGain();
        lfoGain.gain.value = 300;
        
        lfo.connect(lfoGain);
        lfoGain.connect(filter.frequency);
        noise.connect(filter);
        filter.connect(this.bgmGain);
        
        noise.start();
        lfo.start();
        this.oceanNode = { noise, lfo };
    }

    playNote() {
        if(!this.isPlaying) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        const note = this.notes[Math.floor(Math.random() * this.notes.length)];
        const freq = Math.random() > 0.7 ? note * 2 : note;
        
        osc.frequency.value = freq;
        osc.type = 'sine';
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.15, this.ctx.currentTime + 2); 
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8); 
        
        osc.connect(gain);
        gain.connect(this.bgmGain);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 8);
    }

    duckBgm(duration) {
        if (!this.bgmGain) return;
        const t = this.ctx.currentTime;
        this.bgmGain.gain.cancelScheduledValues(t);
        this.bgmGain.gain.setValueAtTime(this.bgmGain.gain.value, t);
        this.bgmGain.gain.linearRampToValueAtTime(0.2, t + 0.1);
        this.bgmGain.gain.linearRampToValueAtTime(1.0, t + duration);
    }

    playCardSlide() {
        if(!this.isPlaying) return;
        const t = this.ctx.currentTime;
        const noise = this.createPinkNoise();
        const noiseGain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(800, t);
        filter.frequency.linearRampToValueAtTime(1200, t + 0.1);

        noiseGain.gain.setValueAtTime(0.4, t); 
        noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15); 

        noise.connect(filter);
        filter.connect(noiseGain);
        noiseGain.connect(this.sfxGain);

        noise.start(t);
        noise.stop(t + 0.15);
    }

    playTick() {
        if(!this.isPlaying) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.type = 'triangle';
        osc.frequency.setValueAtTime(400, t);
        gain.gain.setValueAtTime(1.5, t); 
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);

        osc.connect(gain);
        gain.connect(this.sfxGain);

        osc.start(t);
        osc.stop(t + 0.05);
    }

    playCoin() {
        if(!this.isPlaying) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1500 + Math.random() * 500, t);
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        osc.connect(gain);
        gain.connect(this.sfxGain);
        osc.start(t);
        osc.stop(t + 0.1);
    }

    playWin() {
        if(!this.isPlaying) return;
        this.duckBgm(2.5);
        const t = this.ctx.currentTime;
        const freqs = [523.25, 659.25, 783.99]; 
        freqs.forEach((f, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.value = f;
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.4, t + 0.1 + (i*0.05)); 
            gain.gain.exponentialRampToValueAtTime(0.001, t + 2.0); 
            osc.connect(gain);
            gain.connect(this.sfxGain);
            osc.start(t);
            osc.stop(t + 2.0);
        });
    }

    playLose() {
        if(!this.isPlaying) return;
        this.duckBgm(1.5);
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(80, t + 1.5); 
        gain.gain.setValueAtTime(0.4, t);
        gain.gain.linearRampToValueAtTime(0, t + 1.5);
        osc.connect(gain);
        gain.connect(this.sfxGain);
        osc.start(t);
        osc.stop(t + 1.5);
    }

    toggle() {
        this.init();
        if (this.ctx.state === 'suspended') this.ctx.resume();
        if (this.isPlaying) {
            this.stop();
        } else {
            this.start();
        }
        return this.isPlaying;
    }

    start() {
        if(this.isPlaying) return;
        this.isPlaying = true;
        this.startOcean();
        this.playNote();
        this.synthInterval = setInterval(() => {
            if(Math.random() > 0.4) this.playNote();
        }, 4000);
    }

    stop() {
        this.isPlaying = false;
        if(this.oceanNode) {
            this.oceanNode.noise.stop();
            this.oceanNode.lfo.stop();
            this.oceanNode = null;
        }
        if(this.synthInterval) clearInterval(this.synthInterval);
    }
}

// =================== é…ç½®åŒº ===================
const LEVEL_CONFIG = [];
for (let floor = 1; floor <= 8; floor++) {
    // [New Level System v3.0.0]
    // Step 1: Best of 3 (x-1)
    LEVEL_CONFIG.push({
        id: `${floor}-1`,
        floor: floor,
        step: 1,
        target: 'best_of_3',
        gold: 0,
        rounds: 3,
        openHand: false,
        name: 'æš—ç‰Œ-3å±€2èƒœ',
        desc: '3å±€2èƒœï¼Œå›åˆç‰Œå‹èµ¢è¿‡å¯¹æ–¹å³èƒœ',
        rewardPick: 3,
        rewardGet: 1
    });
    // Step 2: Boss Accumulate (x-2) - Renamed from old x-3
    LEVEL_CONFIG.push({
        id: `${floor}-2`, 
        floor: floor,
        step: 2,
        target: 'accumulate',
        gold: 400 * floor,
        rounds: 3,
        openHand: false, 
        name: 'æš—ç‰Œ-é‡‘å¸æŒ‘æˆ˜',
        desc: `3 å›åˆå†…é‡‘å¸ > x/${400 * floor}`,
        rewardPick: 4,
        rewardGet: 2,
        boss: true
    });
}

const OPPONENT_PERSONAS = {
    1: [ {name:"é›¾éšå®¢", text:"é›¾é”ç‰Œè·¯ï¼Œä½ è¿è‡ªå·±éƒ½çœ‹ä¸æ¸…ã€‚"}, {name:"å½±å¼ˆè€…", text:"ä½ çš„æ‰‹ï¼Œæ—©è¢«æˆ‘çš„å½±å­æ¡ä½äº†ã€‚"}, {name:"æ— ç›¸å¸å‘½", text:"å‘½æ— å®šå½¢ï¼Œæ±äº¦æ— èƒœæœºã€‚"} ],
    2: [ {name:"è§æƒ‘ä½¿", text:"ç«æ˜Ÿç…§å‘½ï¼Œæ­¤å±€è¡€å…‰å·²ç°ã€‚"}, {name:"å²ç ´å¾’", text:"ç ´ä½ å¸ƒå±€ï¼Œå¦‚æŠ˜æ¯æã€‚"}, {name:"åŒ—æ–—åˆ‘å®˜", text:"ä¸ƒæ˜Ÿè½å­ï¼Œç½ªç½šå·²å®šã€‚"} ],
    3: [ {name:"æ¢¦ç¼šå¸ˆ", text:"æ²‰æººæ—§æ¢¦è€…ï¼Œä¸é…é†’ç€èµ¢ã€‚"}, {name:"çµçŠ€ç›—", text:"ä½ çš„å¿ƒæ„ï¼Œæˆ‘å·²å·æ¥çœ‹é€ã€‚"}, {name:"å¿˜å·å®ˆç—´", text:"æ‰§å¿µå¤ªé‡ï¼Ÿé‚£å°±æ°¸ç•™æ­¤å²¸ã€‚"} ],
    4: [ {name:"ç„°éª°å®¢", text:"èµŒå¾—è¶Šå¤§ï¼Œçƒ§å¾—è¶Šå¹²å‡€ã€‚"}, {name:"é‡‘ç³å¾’", text:"é‡‘å¸é—ªå…‰æ—¶ï¼Œä¾¿æ˜¯ä½ å¤±æ˜ä¹‹åˆ»ã€‚"}, {name:"é¥•å¼ˆå°Š", text:"è´ªå¿ƒä¸è¶³ï¼Ÿæ­£å¥½å–‚æˆ‘æ£‹è…¹ã€‚"} ],
    5: [ {name:"è™šè¨€ä½¿", text:"æˆ‘è¯´çœŸè¯ï¼Œä½†ä½ ä¿¡å—ï¼Ÿ"}, {name:"å›å£°å®¢", text:"ä½ ä¸Šä¸€æ­¥ï¼Œå·²æ˜¯æˆ‘çš„ä¼ç¬”ã€‚"}, {name:"åƒé¢ç‹å›", text:"çŒœçŒœè¿™å‰¯é¢å…·ä¸‹ï¼Œæ˜¯ç¬‘è¿˜æ˜¯æ€ï¼Ÿ"} ],
    6: [ {name:"å¹»æ½®å¸ˆ", text:"ç‰Œå¦‚æ½®æ¶Œï¼Œç†æ™ºå°†æ²‰ã€‚"}, {name:"å¦„å¿µå¾’", text:"ä½ ä»¥ä¸ºçš„èƒœç®—ï¼Œåªæ˜¯å¹»è§‰ã€‚"}, {name:"å¤§å¦„å¤©ç‹", text:"å¤©åœ°çš†å¦„ï¼Œå”¯æˆ‘å¼ˆçœŸã€‚"} ],
    7: [ {name:"å¯‚é»˜å®¢", text:"æ²‰é»˜ï¼Œæ˜¯ä½ æœ€åçš„å£°éŸ³ã€‚"}, {name:"ç©ºç—•ä½¿", text:"ç—•è¿¹ä¸ç•™ï¼Œèƒœè´¥æˆç©ºã€‚"}, {name:"å½’å¯‚ç™½ç‹", text:"æ”¾ä¸‹èƒœè´Ÿï¼Œæˆ–æ°¸é™·è™šæ— ã€‚"} ],
    8: [ {name:"å¿ƒé•œå¸ˆ", text:"ç…§è§ä½ å¿ƒåº•çš„ç ´ç»½äº†ã€‚"}, {name:"å°¾è¿¹å®¢", text:"ä¹å°¾ç•™ç—•ï¼Œæ­¥æ­¥çš†æˆ‘é¢„è®¾ã€‚"}, {name:"ä¹å°¾å¼ˆå¿ƒå›", text:"å…«é‡è¯•ç‚¼å°½ï¼Œå¯æ•¢ä¸æˆ‘å¼ˆå¿ƒï¼Ÿ"} ]
};

const SKILLS_DB = {
    xuanji: { name: 'ç„æœº', icon: 'ğŸŒ€', desc: 'é€‰1-5å¼ ç‰Œå¼ƒæ‰é‡æŠ½', type: 'limit', maxUses: 4 },
    yundu: { name: 'äº‘æ¸¡', icon: 'â˜ï¸', desc: 'é€‰1å¼ ç‰Œä¸å¯¹æ‰‹äº¤æ¢', type: 'limit', maxUses: 4 },
    huanzhu: { name: 'å¹»æ³¨', icon: 'ğŸ’¸', desc: 'ä»…BOSSå…³æ¯å›åˆä¸€æ¬¡: ä¸‹æ³¨', type: 'once_per_round' },
    xinjing: { name: 'å¿ƒé•œ', icon: 'ğŸ”®', desc: 'çœ‹è¯±é¥µ (æœ¬å…³1æ¬¡)', type: 'limit', maxUses: 1 },
    abyss: { name: 'æ·±æ¸Šä¹‹çœ¼', icon: 'ğŸ‘ï¸', desc: 'çœ‹æ‰‹ç‰Œ (æœ¬å±‚1æ¬¡)', type: 'limit', maxUses: 1 },
    mirror: { name: 'é•œç•Œ', icon: 'ğŸª', desc: 'å¤åˆ¶å¯¹æ‰‹æ‰‹ç‰Œ (æœ¬å±‚1æ¬¡)', type: 'limit', maxUses: 1 },
    blast: { name: 'çˆ†ç ´', icon: 'ğŸ’¥', desc: 'æŒ‡å®šæ¢ç‰Œ (æœ¬å±‚2æ¬¡)', type: 'limit', maxUses: 2 }
};

const REWARD_POOL = [
    { id: 'shuangying', weight: 60, name: 'åŒå½±', desc: 'ã€å¯¹å­ã€‘é‡‘å¸+100', type: 'passive', icon: 'â™Š', trigger:'å¯¹å­', val:100 },
    { id: 'sixiang', weight: 60, name: 'å››è±¡', desc: 'ã€ä¸¤å¯¹ã€‘é‡‘å¸+100', type: 'passive', icon: 'ğŸ˜', trigger:'ä¸¤å¯¹', val:100 },
    { id: 'sanyuan', weight: 60, name: 'ä¸‰å£', desc: 'ã€ä¸‰æ¡ã€‘é‡‘å¸+200', type: 'passive', icon: 'â­', trigger:'ä¸‰æ¡', val:200 },
    { id: 'lianchao', weight: 60, name: 'è¿æ½®', desc: 'ã€é¡ºå­ã€‘é‡‘å¸+200', type: 'passive', icon: 'ğŸŒŠ', trigger:'é¡ºå­', val:200 },
    { id: 'yise', weight: 60, name: 'ä¸€è‰²', desc: 'ã€åŒèŠ±ã€‘é‡‘å¸+200', type: 'passive', icon: 'ğŸ¨', trigger:'åŒèŠ±', val:200 },
    { id: 'fulu', weight: 60, name: 'ç¦ç¦„', desc: 'ã€è‘«èŠ¦ã€‘é‡‘å¸+300', type: 'passive', icon: 'ğŸº', trigger:'è‘«èŠ¦', val:300 },
    { id: 'siji', weight: 60, name: 'å››æ', desc: 'ã€å››ç‚¸ã€‘é‡‘å¸+300', type: 'passive', icon: 'âš¡', trigger:'å››ç‚¸', val:300 },
    { id: 'tianlv', weight: 60, name: 'å¤©å¾‹', desc: 'ã€åŒèŠ±é¡ºã€‘é‡‘å¸+300', type: 'passive', icon: 'ğŸ“œ', trigger:'åŒèŠ±é¡º', val:300 },
    
    { id: 'xinjing', weight: 20, name: 'å¿ƒé•œ', desc: 'çœ‹è¯±é¥µ (æœ¬å…³1æ¬¡)', type: 'item_active', ref: 'xinjing', unique: true, icon: 'ğŸ”®' },
    { id: 'abyss', weight: 20, name: 'æ·±æ¸Šä¹‹çœ¼', desc: 'çœ‹æ‰‹ç‰Œ (æœ¬å±‚1æ¬¡)', type: 'item_active', ref: 'abyss', unique: true, icon: 'ğŸ‘ï¸' },
    { id: 'mirror', weight: 20, name: 'é•œç•Œ', desc: 'å¤åˆ¶å¯¹æ‰‹æ‰‹ç‰Œ (æœ¬å±‚1æ¬¡)', type: 'item_active', ref: 'mirror', unique: true, icon: 'ğŸª' },
    { id: 'blast', weight: 20, name: 'çˆ†ç ´', desc: 'æŒ‡å®šæ¢ç‰Œ (æœ¬å±‚2æ¬¡)', type: 'item_active', ref: 'blast', unique: true, icon: 'ğŸ’¥' },
    
    { id: 'yunyan', weight: 10, name: 'äº‘è¡', desc: 'äº‘æ¸¡æœ¬å±‚ä¸Šé™+1ï¼Œç«‹å³æ¬¡æ•°+1', type: 'upgrade', icon: 'ğŸ†™', effect: 'add_yundu' },
    { id: 'xuanshu', weight: 10, name: 'ç„æ¢', desc: 'ç„æœºæœ¬å±‚ä¸Šé™+1ï¼Œç«‹å³æ¬¡æ•°+1', type: 'upgrade', icon: 'ğŸ†™', effect: 'add_xuanji' },
    { id: 'huance', weight: 10, name: 'å¹»ç­–', desc: 'å¹»æ³¨æ¯”ä¾‹æå‡10%', type: 'upgrade', icon: 'ğŸ’¹', effect: 'boost_bet' },
    { id: 'xinyu', weight: 5, name: 'å¿ƒå±¿', desc: 'æŠ€èƒ½æ§½ä½+1', type: 'upgrade', icon: 'ğŸ§©', effect: 'add_slot' },
    
    { id: 'yangyao', weight: 20, name: 'é˜³çˆ»', desc: 'å¥‡æ•°ç‰Œ æ¯å¼ +100', type: 'passive', icon: 'ğŸ”†', trigger: 'odd', val: 100 },
    { id: 'yinyao', weight: 20, name: 'é˜´çˆ»', desc: 'å¶æ•°ç‰Œ æ¯å¼ +100', type: 'passive', icon: 'ğŸŒ‘', trigger: 'even', val: 100 },
    { id: 'qishi', weight: 20, name: 'éª‘å£«', desc: 'äººå¤´ç‰Œ æ¯å¼ +2å€', type: 'passive', icon: 'ğŸ›¡ï¸', trigger: 'face', mult: 2 },
    { id: 'chaodie', weight: 20, name: 'æ½®å ', desc: 'ã€ä¸¤å¯¹ã€‘å€ç‡+2', type: 'passive', icon: 'ğŸŒŠ', trigger: 'ä¸¤å¯¹', mult: 2 },
    { id: 'xingcu', weight: 20, name: 'æ˜Ÿç°‡', desc: 'ã€ä¸‰æ¡ã€‘å€ç‡+2', type: 'passive', icon: 'âœ¨', trigger: 'ä¸‰æ¡', mult: 2 },
    { id: 'liuxu', weight: 20, name: 'æµåº', desc: 'ã€é¡ºå­ã€‘å€ç‡+2', type: 'passive', icon: 'ğŸƒ', trigger: 'é¡ºå­', mult: 2 },
    { id: 'zhanyi', weight: 20, name: 'æ¹›ä¸€', desc: 'ã€åŒèŠ±ã€‘å€ç‡+2', type: 'passive', icon: 'ğŸ’§', trigger: 'åŒèŠ±', mult: 2 },
    { id: 'xuanhe', weight: 20, name: 'ç„åˆ', desc: 'ã€è‘«èŠ¦ã€‘å€ç‡+3', type: 'passive', icon: 'ğŸ”—', trigger: 'è‘«èŠ¦', mult: 3 },
    { id: 'jiyao', weight: 20, name: 'ææ›œ', desc: 'ã€å››ç‚¸ã€‘å€ç‡+3', type: 'passive', icon: 'ğŸŒ', trigger: 'å››ç‚¸', mult: 3 },
    { id: 'minglv', weight: 20, name: 'æºŸå¾‹', desc: 'ã€åŒèŠ±é¡ºã€‘å€ç‡+3', type: 'passive', icon: 'ğŸŒŒ', trigger: 'åŒèŠ±é¡º', mult: 3 }
];

const HAND_TYPES_BASE = [
    { name: 'åŒèŠ±é¡º', en:'Straight Flush', base: 300, level:9 }, { name: 'å››ç‚¸', en:'Four of a Kind', base: 200, level:8 }, 
    { name: 'è‘«èŠ¦', en:'Full House', base: 160, level:7 }, { name: 'åŒèŠ±', en:'Flush', base: 120, level:6 }, 
    { name: 'é¡ºå­', en:'Straight', base: 90, level:5 }, { name: 'ä¸‰æ¡', en:'Three of a Kind', base: 60, level:4 }, 
    { name: 'ä¸¤å¯¹', en:'Two Pair', base: 40, level:3 }, { name: 'å¯¹å­', en:'Pair', base: 20, level:2 }, 
    { name: 'å•ç‰Œ', en:'High Card', base: 10, level:1 }
];
const SUITS = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
const RANK_VALUES = { '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, '10':10, 'J':11, 'Q':12, 'K':13, 'A':14 };
const SUIT_VALS = { 'â™ ':4, 'â™¥':3, 'â™¦':2, 'â™£':1 };

const PokerEngine = {
    evaluate: (cards) => {
        if (!cards || cards.length < 5) return { score: 0, name: 'ä¸è¶³', payout: 0, cards: [] };
        let sorted = [...cards].sort((a,b) => b.value - a.value);
        const v = sorted.map(c => c.value); const s = sorted.map(c => c.suit);
        const isFlush = s.every(x => x === s[0]); let isStraight = true;
        for(let i=0; i<4; i++) { if(v[i] - v[i+1] !== 1) isStraight = false; }
        if(!isStraight && v[0]===14 && v[1]===5 && v[2]===4 && v[3]===3 && v[4]===2) isStraight = true;
        const counts = {}; v.forEach(x => counts[x] = (counts[x] || 0) + 1);
        const arr = Object.values(counts).sort((a,b) => b - a);
        let t = HAND_TYPES_BASE[8];
        if(isFlush && isStraight) t = HAND_TYPES_BASE[0]; else if(arr[0]===4) t = HAND_TYPES_BASE[1]; else if(arr[0]===3 && arr[1]===2) t = HAND_TYPES_BASE[2]; else if(isFlush) t = HAND_TYPES_BASE[3]; else if(isStraight) t = HAND_TYPES_BASE[4]; else if(arr[0]===3) t = HAND_TYPES_BASE[5]; else if(arr[0]===2 && arr[1]===2) t = HAND_TYPES_BASE[6]; else if(arr[0]===2) t = HAND_TYPES_BASE[7];
        
        sorted.sort((a, b) => {
            const ca = counts[a.value], cb = counts[b.value];
            if(ca !== cb) return cb - ca; 
            if(a.value !== b.value) return b.value - a.value; 
            return SUIT_VALS[b.suit] - SUIT_VALS[a.suit];
        });
        
        let raw = t.level * 1000000000000;
        sorted.forEach((c, i) => {
             const cardScore = c.value * 10 + SUIT_VALS[c.suit];
             raw += cardScore * Math.pow(200, 4 - i);
        });
        return { ...t, rawScore: raw, cards: sorted };
    },
    getStrategicBait: (hand, isBoss) => {
        let sorted = [...hand].sort((a,b)=>a.value-b.value);
        let bait = [], keep = [];
        const rand = Math.random();
        if (!isBoss) {
            if (rand > 0.5) { bait = [sorted[0], sorted[1]]; keep = sorted.slice(2); } 
            else { bait = [sorted[0], sorted[6]]; keep = sorted.slice(1,6); }
        } else {
            if (rand > 0.66) { bait = [sorted[0], sorted[1]]; keep = sorted.slice(2); } 
            else if (rand > 0.33) { bait = [sorted[0], sorted[6]]; keep = sorted.slice(1,6); } 
            else { bait = [sorted[2], sorted[3]]; keep = [sorted[0], sorted[1], sorted[4], sorted[5], sorted[6]]; }
        }
        return { bait, keep };
    },
    getBestCombo: (hand, bait) => {
        let bestRes = { rawScore: -1 }; const combinations = [];
        const f = (start, combo) => { if (combo.length === 3) { combinations.push(combo); return; } for (let i = start; i < hand.length; i++) { f(i + 1, [...combo, hand[i]]); } }; f(0, []);
        combinations.forEach(comboHand => { const fullHand = [...comboHand, ...bait]; const res = PokerEngine.evaluate(fullHand); if(res.rawScore > bestRes.rawScore) bestRes = res; });
        return bestRes;
    },
    isTooStrong: (cards) => {
        const suits = {};
        cards.forEach(c => suits[c.suit] = (suits[c.suit]||0) + 1);
        if (Object.values(suits).some(c => c >= 4)) return true; // Nerf: No possible flush

        const values = cards.map(c => c.value).sort((a,b)=>a-b);
        const counts = {};
        values.forEach(v => counts[v] = (counts[v]||0) + 1);
        const countVals = Object.values(counts);
        
        if (countVals.some(c => c >= 3)) return true; 
        if (countVals.filter(c => c === 2).length >= 2) return true;

        const uniqueVals = [...new Set(values)];
        if (uniqueVals.length >= 4) {
             for(let i=0; i <= uniqueVals.length - 4; i++) {
                if (uniqueVals[i+3] - uniqueVals[i] === 3) return true; 
             }
        }
        return false;
    }
};

class Card {
    constructor(s, r) { this.suit = s; this.rank = r; this.value = RANK_VALUES[r]; this.isRed = (s==='â™¥'||s==='â™¦'); this.id = Math.random().toString(36).slice(2); this.revealed = false; }
}

class Game {
    constructor() { 
        this.resetGlobal(); 
        this.initDOM(); 
        this.audio = new AtmosphereAudio(); 
        this.isAudioOn = true; 
        this.inGame = false; // Track if we are in game or lobby
        this.initSplash();
    }

    initSplash() {
        const splash = document.getElementById('splash-screen');
        // Start audio interaction on click anywhere if blocked
        document.addEventListener('click', () => {
            this.audio.init();
            if(this.isAudioOn) {
                this.audio.start();
                this.updateAudioBtn(true);
            }
        }, { once: true });

        // Auto fade out splash
        setTimeout(() => {
            splash.classList.add('fade-out');
            setTimeout(() => {
                splash.style.display = 'none';
                this.showLobby();
            }, 1500);
        }, 3000);
    }

    resetGlobal() {
        this.levelIndex = 0; 
        this.playerGold = 0; 
        this.activeSkills = ['xuanji', 'yundu', 'huanzhu'];
        this.skillUsage = { xuanji: SKILLS_DB.xuanji.maxUses, yundu: SKILLS_DB.yundu.maxUses };
        this.skillMaxModifiers = { xuanji: 0, yundu: 0 };
        this.passives = []; this.obtainedItems = []; this.upgradeCounts = { yunyan: 0, xuanshu: 0, huance: 0 };
        this.betUsedThisRound = false; this.betRatios = [0.3, 0.5]; this.maxSlots = 6; this.bossDeck = null;
        this.drawPile = [];
        this.discardPile = [];
        this.opponentName = ""; 
        this.selectedOppCard = null;
        this.justDealt = false;
        this.inGame = false;
        this.currentLevelWins = 0; 
        this.currentLevelLosses = 0;
    }

    showLobby() {
        // Ensure audio starts if not started
        this.audio.init();
        if(this.isAudioOn) this.audio.start();
    }

    startGame() { 
        document.getElementById('lobby-screen').style.display = 'none'; 
        document.getElementById('header-left-col').classList.remove('lobby-hide');
        document.getElementById('header-right-col').classList.remove('lobby-hide');
        
        // Hide info if open from lobby
        document.getElementById('info-screen').classList.remove('visible');

        this.setOverlayState(true); // Tutorial overlay is active
        document.getElementById('tutorial-screen').classList.add('visible'); 
        this.inGame = true;
        this.toggleFullscreen(); 
    }

    setOverlayState(active) {
        if(active) document.body.classList.add('overlay-active');
        else document.body.classList.remove('overlay-active');
    }

    toggleAudio() {
        const isPlaying = this.audio.toggle();
        this.isAudioOn = isPlaying;
        this.updateAudioBtn(isPlaying);
    }

    updateAudioBtn(playing) {
        const btn = document.getElementById('audio-toggle');
        if(playing) {
            btn.classList.add('audio-active');
            btn.style.opacity = '1';
        } else {
            btn.classList.remove('audio-active');
            btn.style.opacity = '0.5';
        }
    }

    toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                // console.log(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }

    enterLevelOne() { 
        document.getElementById('tutorial-screen').classList.remove('visible'); 
        this.setOverlayState(false); 
        this.startLevel(); 
    }
    returnToLobby() { 
        this.resetGlobal(); 
        document.getElementById('overlay-screen').classList.remove('visible'); 
        this.setOverlayState(false);
        document.getElementById('lobby-screen').style.display = 'flex';
        document.getElementById('header-left-col').classList.add('lobby-hide');
        document.getElementById('header-right-col').classList.add('lobby-hide');
        this.inGame = false;
    }
    
    initDOM() { 
        document.getElementById('btn-bait').onclick = () => this.confirmBait(); 
        document.getElementById('btn-combo-opp').onclick = () => this.playRound('opp'); 
        document.getElementById('btn-combo-mine').onclick = () => this.playRound('mine'); 
        document.getElementById('btn-play-hand').onclick = () => this.playRound('hand'); 
        document.getElementById('btn-skill-ok').onclick = () => this.executeSkill(); 
        document.getElementById('btn-skill-no').onclick = () => this.cancelSkill(); 

        const tooltip = document.getElementById('global-tooltip');
        
        document.getElementById('passive-list').addEventListener('mouseover', (e) => {
             const target = e.target.closest('.passive-icon');
             if(target) {
                 const desc = target.getAttribute('data-desc');
                 if(desc) {
                     tooltip.innerText = desc;
                     tooltip.style.display = 'block';
                     const rect = target.getBoundingClientRect();
                     tooltip.style.left = Math.min(window.innerWidth - 240, Math.max(10, rect.left - 100)) + 'px';
                     tooltip.style.top = (rect.bottom + 10) + 'px';
                 }
             }
        });
        document.getElementById('passive-list').addEventListener('mouseout', (e) => {
             tooltip.style.display = 'none';
        });
        document.getElementById('passive-list').addEventListener('click', (e) => {
             const target = e.target.closest('.passive-icon');
             if(target) {
                 const desc = target.getAttribute('data-desc');
                 if(desc) {
                     tooltip.innerText = desc;
                     tooltip.style.display = 'block';
                     const rect = target.getBoundingClientRect();
                     tooltip.style.left = Math.min(window.innerWidth - 240, Math.max(10, rect.left - 100)) + 'px';
                     tooltip.style.top = (rect.bottom + 10) + 'px';
                     setTimeout(() => tooltip.style.display = 'none', 3000);
                 }
             }
        });
    }

    startLevel() {
        this.config = LEVEL_CONFIG[this.levelIndex];
        if(this.config.step === 1) { 
            this.skillUsage.xuanji = SKILLS_DB.xuanji.maxUses + this.skillMaxModifiers.xuanji; 
            this.skillUsage.yundu = SKILLS_DB.yundu.maxUses + this.skillMaxModifiers.yundu; 
            this.skillUsage.abyss = SKILLS_DB.abyss.maxUses; 
            this.skillUsage.mirror = SKILLS_DB.mirror.maxUses;
            this.skillUsage.xinjing = SKILLS_DB.xinjing.maxUses;
            this.skillUsage.blast = SKILLS_DB.blast.maxUses;
            // v3.0.0 Win Reset
            this.currentLevelWins = 0; 
            this.currentLevelLosses = 0;
        }
        this.activeSkills.forEach(k => { const s = SKILLS_DB[k]; if(s.type === 'level_limit') this.skillUsage[k] = s.maxUses; });
        if(this.config.boss) this.bossDeck = this.createDeck();
        this.currentRound = 1; this.levelEarnedGold = 0; this.currentTargetGold = this.config.gold; 
        
        this.setupPersona();
        this.updateHeader(); this.startRound();
    }

    setupPersona() {
        const floor = this.config.floor; const step = this.config.step;
        // v3.0.0 Map Persona: Step 1 -> Index 0, Step 2 -> Index 2 (Boss)
        const personas = OPPONENT_PERSONAS[floor] || OPPONENT_PERSONAS[1];
        const persona = personas[step === 1 ? 0 : 2]; 
        
        this.opponentName = persona.name;
        document.querySelector('.avatar').style.backgroundImage = `url('https://api.dicebear.com/7.x/bottts/svg?seed=${this.opponentName}')`;
        document.getElementById('opp-name').innerText = this.opponentName;
        const img = new Image(); img.src = `https://api.dicebear.com/7.x/bottts/svg?seed=${this.opponentName}`;
        img.onerror = () => { document.querySelector('.avatar').style.backgroundImage = "none"; document.querySelector('.avatar').innerHTML = "ğŸ¤–"; };
        setTimeout(() => this.speak(persona.text), 2000);
    }
    speak(text) {
        const bubble = document.getElementById('opp-speech'); bubble.innerText = ""; bubble.style.opacity = 1;
        let i = 0; const speed = 50; 
        const typeWriter = () => { if (i < text.length) { bubble.innerText += text.charAt(i); i++; setTimeout(typeWriter, speed); } else { setTimeout(() => { bubble.style.opacity = 0; }, 4000); } };
        typeWriter();
    }

    createDeck() { 
        let deck = []; SUITS.forEach(s => RANKS.forEach(r => deck.push(new Card(s,r)))); 
        deck.sort(() => Math.random() - 0.5); 
        if(this.config.rule === 'wild_6') { deck.forEach(c => { if(c.rank === '6') { c.suit = 'â™¦'; c.isRed = true; } }); } 
        return deck; 
    }
    
    startRound() {
        let deck; if(this.config.boss) { deck = this.bossDeck; } else { deck = this.createDeck(); }
        this.drawPile = this.config.boss ? deck : this.createDeck();
        this.discardPile = []; // v3.0.1 Reset Discard Pile for new round
        
        // v3.0.1 Fix Draw Function with Recycle Logic
        const draw = (n) => { 
            const c = []; 
            if (this.drawPile.length < n && this.discardPile.length > 0) {
                // Recycle discards if draw pile is empty
                this.drawPile.push(...this.discardPile);
                this.discardPile = [];
                this.drawPile.sort(() => Math.random() - 0.5);
            }
            // Even after recycle, if still not enough, we just draw what's left (should be 52 max anyway)
            for(let i=0;i<n;i++) if(this.drawPile.length>0) c.push(this.drawPile.pop()); 
            return c; 
        };

        this.playerHand = draw(7).sort((a,b)=>b.value - a.value);
        
        let aiHand = [];
        // [Optimized Nerf] Check for early levels (Floors 1 & 2, Step 1)
        const isNerfLevel = (this.config.floor <= 2 && this.config.step === 1);
        
        if (isNerfLevel) {
            let attempts = 0;
            while (attempts < 20) {
                aiHand = draw(7);
                if (!PokerEngine.isTooStrong(aiHand)) {
                    break; 
                }
                this.drawPile.push(...aiHand);
                this.drawPile.sort(() => Math.random() - 0.5);
                aiHand = [];
                attempts++;
            }
            if (aiHand.length === 0) aiHand = draw(7); 
        } else {
            aiHand = draw(7);
        }
        
        this.oppHand = aiHand.sort((a,b)=>b.value - a.value);
        this.playerBait = []; this.oppBait = []; this.selectedCards = []; this.selectedOppCard = null; this.skillMode = null; this.phase = 'BAIT'; this.currentBet = 0; this.betUsedThisRound = false;
        this.activeSkills.forEach(k => { const s = SKILLS_DB[k]; if(s.type === 'round_limit') this.skillUsage[k] = s.maxUses; });
        this.justDealt = true;
        this.updateHeader(); this.renderScene(); this.updateControls();
    }

    // 2.1.6 Modified Eval to support breakdown
    evalHandValue(cards) {
        const isWild = (this.config.rule === 'wild_6'); const res = PokerEngine.evaluate(cards, isWild);
        
        let base = res.base; // Original Base
        let typeBonus = 0;   // Flat bonus from Hand Type Passives
        let itemBonus = 0;   // Flat bonus from Item Passives
        let mult = 0;        // Total Multiplier
        let triggeredItems = [];

        this.passives.forEach(p => { 
            // Hand Type Flat Bonuses
            if (['shuangying','sixiang','sanyuan','lianchao','yise','fulu','siji','tianlv'].includes(p.id)) {
                 if(p.trigger === res.name) { 
                     typeBonus += p.val; 
                 }
            } 
            // Item Flat/Mult Bonuses
            else {
                 let triggered = false;
                 if(p.trigger === 'odd') { if(cards.some(c=>['A','3','5','7','9'].includes(c.rank))) { itemBonus += (p.val * cards.filter(c=>['A','3','5','7','9'].includes(c.rank)).length); triggered=true; } } // Simplify: Each card triggers? No, just logic check.
                 // Correct logic from previous: 
                 else if(p.trigger === 'odd') { cards.forEach(c => { if(['A','3','5','7','9'].includes(c.rank)) itemBonus += p.val; }); triggered=true; } // Always triggers if any? Let's assume yes for UI
                 else if (p.trigger === 'even') { cards.forEach(c => { if(['2','4','6','8','10'].includes(c.rank)) itemBonus += p.val; }); triggered=true; } 
                 else if (p.trigger === 'face') { cards.forEach(c => { if(['J','Q','K'].includes(c.rank)) mult += p.mult; }); triggered=true; } 
                 else if(p.trigger === res.name) { 
                     if(p.val) itemBonus += p.val; 
                     if(p.mult) mult += p.mult; 
                     triggered=true;
                 }
                 
                 if(triggered && !triggeredItems.includes(p.name)) triggeredItems.push(p.name);
            }
        });

        // 2.1.6 Display Split Logic Data
        // Row 1: Hand + TypeBonus
        let row1_val = base + typeBonus;
        // Row 2: ItemBonus + Multiplier Effect
        // Total = (Row1 + ItemBonus) * (1+Mult)
        // Row 2 Display = Total - Row1
        let total = (row1_val + itemBonus) * (1 + mult);
        let row2_val = total - row1_val;

        return { ...res, payout: total, row1: row1_val, row2: row2_val, items: triggeredItems };
    }

    renderScene() {
        const hC = document.getElementById('hand-container'); hC.innerHTML = '';
        this.playerHand.forEach((c, idx) => {
            const el = document.createElement('div'); el.innerHTML = this.htmlCard(c, false, true, false); const dom = el.firstElementChild;
            if(this.justDealt) { 
                dom.classList.add('card-deal-anim'); 
                dom.style.animationDelay = `${idx * 0.15}s`; 
                setTimeout(() => this.audio.playCardSlide(), idx * 150);
            }
            if(this.selectedCards.includes(c)) dom.classList.add('selected'); if(this.skillMode === 'yundu' || this.skillMode === 'blast') dom.style.borderColor = '#d580ff';
            if(this.config.rule === 'no_hearts' && c.suit === 'â™¥' && this.phase === 'ACTION' && this.skillMode === null) { dom.style.opacity = '0.5'; dom.style.cursor = 'not-allowed'; } else { dom.onclick = () => this.onCardClick(c); }
            hC.appendChild(dom);
        });
        if(this.justDealt) setTimeout(() => this.justDealt = false, 1500);

        const oppC = document.getElementById('opp-hand-container'); oppC.innerHTML = ''; document.getElementById('opp-count').innerText = this.oppHand.length;
        this.oppHand.forEach(c => { const show = this.config.openHand || c.revealed; 
            const el = document.createElement('div'); el.innerHTML = this.htmlCard(c, true, show, false); const dom = el.firstElementChild;
            if(this.selectedOppCard && this.selectedOppCard.id===c.id) dom.classList.add('opp-selected');
            if(this.skillMode==='blast') dom.onclick = ()=>this.onOppCardClick(c);
            oppC.appendChild(dom);
        });
        const myB = document.getElementById('my-bait-container'); const oppB = document.getElementById('opp-bait-container');
        myB.innerHTML = this.playerBait.length===0 ? '<div class="slot-placeholder"></div><div class="slot-placeholder"></div>' : '';
        this.playerBait.forEach(c => myB.innerHTML += this.htmlCard(c, false, true, false));
        oppB.innerHTML = this.oppBait.length===0 ? '<div class="slot-placeholder"></div><div class="slot-placeholder"></div>' : '';
        const baitVis = (this.phase === 'ACTION') || this.config.openHand;
        this.oppBait.forEach(c => {
             const vis = (this.phase === 'ACTION') || this.config.openHand || c.revealed;
             oppB.innerHTML += this.htmlCard(c, false, vis, false);
        });
        this.renderSkills();
    }
    htmlCard(c, mini, face, isBait) {
        if(!face) return `<div class="card ${mini?'mini':''} card-back"></div>`;
        const badge = isBait ? `<div class="badge-bait">æ”¾</div>` : '';
        return `<div class="card ${mini?'mini':''} ${c.isRed?'red':'black'}"><div class="card-rank">${c.rank}</div><div class="card-suit">${c.suit}</div>${badge}</div>`;
    }

    renderSkills() {
        const div = document.getElementById('skill-dock'); div.innerHTML = '';
        this.activeSkills.forEach(k => {
            const s = SKILLS_DB[k]; if(!s) return; const el = document.createElement('div'); el.className = 'skill-item';
            let dis = false; let count = '';
            if(s.type === 'limit' || s.type === 'item_active' || s.type === 'round_limit' || s.type === 'level_limit') {
                count = this.skillUsage[k] !== undefined ? this.skillUsage[k] : s.maxUses; if(count<=0) dis = true;
            } else if (s.type === 'once_per_round') {
                if(k==='huanzhu' && !this.config.boss) dis = true; else if (this.betUsedThisRound && k==='huanzhu') dis = true;
            }
            if(k === 'xinjing' && this.oppBait.length > 0 && this.oppBait[0].revealed) dis = true;
            if(k === 'xinjing' && this.phase !== 'BAIT') dis = true;

            if(dis) el.classList.add('disabled'); el.setAttribute('data-desc', dis&&k==='huanzhu'&&this.betUsedThisRound ? "æœ¬å›åˆå·²ä½¿ç”¨" : s.desc);
            const icon = s.icon || 'ğŸ”°';
            el.innerHTML = `<div style="font-size:20px">${icon}</div><div style="font-size:10px">${s.name}</div>${count!==''?`<div class="skill-count">${count}</div>`:''}`;
            el.onclick = () => { if(!dis) this.activateSkill(k); }
            div.appendChild(el);
        });
    }

    updateControls() {
        const bait=document.getElementById('btn-bait'); const play=document.getElementById('play-group'); const skill=document.getElementById('skill-confirm-group'); const bet=document.getElementById('bet-panel'); const tip=document.getElementById('phase-tip');
        bait.style.display='none'; play.style.display='none'; skill.style.display='none'; bet.style.display='none';
        if(this.skillMode) {
            if(this.skillMode==='huanzhu') {
                document.querySelector('#bet-panel button:nth-child(2)').innerText = `ä¸‹æ³¨ ${(this.betRatios[0]*100)}%`; document.querySelector('#bet-panel button:nth-child(2)').onclick = () => game.placeBet(0);
                document.querySelector('#bet-panel button:nth-child(3)').innerText = `ä¸‹æ³¨ ${(this.betRatios[1]*100)}%`; document.querySelector('#bet-panel button:nth-child(3)').onclick = () => game.placeBet(1);
                bet.style.display='flex'; return; 
            }
            skill.style.display='flex'; document.getElementById('skill-desc-text').innerText = SKILLS_DB[this.skillMode].desc;
            const ok = document.getElementById('btn-skill-ok');
            if(['yundu','blast'].includes(this.skillMode)) ok.disabled = this.selectedCards.length!==1; else if(this.skillMode==='xuanji') ok.disabled = this.selectedCards.length===0; else ok.disabled = false;
            return;
        }
        if(this.phase==='BAIT') {
            tip.innerText = 'è¯·é€‰æ‹© 2 å¼ ä½œä¸ºè¯±é¥µ (å¯å…ˆç”¨æŠ€èƒ½)'; bait.style.display='block'; bait.innerText = `æ”¾å…¥è¯±é¥µ (${this.selectedCards.length}/2)`; bait.disabled = this.selectedCards.length!==2;
        } else {
            tip.innerText = 'ç»„åˆå‡ºç‰Œé˜¶æ®µ'; play.style.display='flex';
            const n = this.selectedCards.length; const b1=document.getElementById('btn-combo-opp'); const b2=document.getElementById('btn-combo-mine'); const b3=document.getElementById('btn-play-hand');
            b1.disabled=b2.disabled=(n!==3); b3.disabled=(n!==5);
            const isWild = (this.config.rule === 'wild_6');
            if(n===3) {
                const r1 = this.evalHandValue([...this.selectedCards, ...this.oppBait], isWild); const r2 = this.evalHandValue([...this.selectedCards, ...this.playerBait], isWild);
                b1.innerHTML = `å’Œtaç»„åˆ å‡º ${r1.name} <span class="gold-val">(${r1.payout})</span>`; b2.innerHTML = `è‡ªå·±ç»„åˆ å‡º ${r2.name} <span class="gold-val">(${r2.payout})</span>`;
            } else { b1.innerText='å’Œ TA è¯±é¥µç»„åˆ'; b2.innerText='å’Œ æˆ‘çš„ è¯±é¥µç»„åˆ'; }
            if(n===5) {
                const r3 = this.evalHandValue(this.selectedCards, isWild); b3.innerHTML = `å‡º ${r3.name} <span class="gold-val">(${r3.payout})</span>`;
            } else { b3.innerText='ç›´æ¥å‡º 5 å¼ æ‰‹ç‰Œ'; }
        }
    }

    onCardClick(c) {
        if(this.config.rule === 'no_hearts' && c.suit === 'â™¥' && this.phase === 'ACTION' && !this.skillMode) return;
        this.audio.playTick();
        if(this.skillMode) {
            if(['yundu','blast'].includes(this.skillMode)) this.selectedCards=[c]; else if(this.skillMode==='xuanji') { const i=this.selectedCards.indexOf(c); if(i>-1)this.selectedCards.splice(i,1); else if(this.selectedCards.length<5)this.selectedCards.push(c); }
            this.renderScene(); this.updateControls(); return;
        }
        const i=this.selectedCards.indexOf(c); if(i>-1)this.selectedCards.splice(i,1); else { const max = this.phase==='BAIT'?2:5; if(this.selectedCards.length<max)this.selectedCards.push(c); }
        this.renderScene(); this.updateControls();
    }
    onOppCardClick(c) {
        if (this.skillMode !== 'blast') return;
        if (!c.revealed && !this.config.openHand) { alert("æ— æ³•é€‰ä¸­æš—ç‰Œï¼è¯·å…ˆæ˜ç‰Œæˆ–ç­‰å¾…æ—¶æœºã€‚"); return; }
        this.audio.playTick();
        this.selectedOppCard = c; this.renderScene(); this.updateControls();
    }

    confirmBait() { 
        this.playerBait = [...this.selectedCards]; 
        this.playerHand = this.playerHand.filter(c=>!this.selectedCards.includes(c)); 
        this.selectedCards = []; 
        if (this.oppBait.length === 0) {
            const strategy = PokerEngine.getStrategicBait(this.oppHand, this.config.boss);
            this.oppBait = strategy.bait; 
            this.oppHand = strategy.keep; 
            if (this.config.openHand) this.oppBait.forEach(c=>c.revealed=true);
        }
        this.phase = 'ACTION'; 
        this.renderScene(); this.updateControls(); 
    }

    playRound(type) {
        let cards = [], baitSrc = 'none';
        if(type==='opp') { cards = [...this.selectedCards, ...this.oppBait]; baitSrc='opp'; } else if(type==='mine') { cards=[...this.selectedCards, ...this.playerBait]; baitSrc='mine'; } else cards=[...this.selectedCards];
        const isWild = (this.config.rule === 'wild_6'); const myRes = this.evalHandValue(cards); 
        const aiBestMine = PokerEngine.getBestCombo(this.oppHand, this.playerBait, isWild); const aiBestOpp  = PokerEngine.getBestCombo(this.oppHand, this.oppBait, isWild); const aiDirect = PokerEngine.evaluate(this.oppHand, isWild); 
        const aiOpts = [{ t:'mine', ...aiBestMine }, { t:'opp', ...aiBestOpp }, { t:'none', ...aiDirect }]; aiOpts.sort((a,b)=>b.rawScore - a.rawScore); const aiRes = aiOpts[0];
        const win = myRes.rawScore > aiRes.rawScore; let reward = 0; let fish = false;
        
        let finalPayout = 0;
        let roundEarned = 0; // Value for level progress
        
        // 3.0.2 Bet Logic:
        // Win: Refund Bet + Profit Bet + (10% of Score). Score counts Profit.
        // Lose: Bet lost. Target increased.

        if(win) {
            this.currentLevelWins++; 
            fish = (baitSrc==='mine' && aiRes.t==='mine');
            
            // Hand Total Value (Base + All Passives)
            let totalHandVal = myRes.payout;
            if (fish) totalHandVal *= 2; // Fish x2 on Total

            // Bet Logic
            let betRefund = 0;
            let betProfit = 0;
            if (this.currentBet > 0) {
                betRefund = this.currentBet;
                betProfit = this.currentBet; // "Extra obtain bet amount"
            }

            // Wallet Add
            // "Final gold = HandValue * 10% + Refund + Profit"
            finalPayout = Math.floor(totalHandVal * 0.10) + betRefund + betProfit;

            // Level Progress (Accumulate)
            // "Recorded in this round's obtained gold" -> HandValue + BetProfit
            roundEarned = totalHandVal + betProfit;
        } else {
            this.currentLevelLosses++; 
            // Lose Bet: Target increases
            if(this.currentBet > 0) this.currentTargetGold += this.currentBet;
            
            // For FAIL display purposes only (what you could have won sans bet profit maybe? or just hand val)
            roundEarned = myRes.payout; 
        }

        this.levelEarnedGold += win ? roundEarned : 0; // Only add to progress if win
        
        this.playerGold += finalPayout; 
        this.updateHeader();
        
        let pass = false; 
        if(this.config.target === 'best_of_3') pass = this.currentLevelWins >= 2; 
        else if(this.config.target==='accumulate') pass = this.levelEarnedGold >= this.currentTargetGold;
        
        let failReason = "";
        if (!win && this.config.target === 'best_of_3') failReason = "æœ¬å±€å¤±è´¥"; 
        
        let isEarlyExitWin = (this.config.target === 'best_of_3' && this.currentLevelWins >= 2);
        let isEarlyExitLoss = (this.config.target === 'best_of_3' && this.currentLevelLosses >= 2);

        if (this.currentRound === 3 && !pass) {
             if (this.config.target === 'best_of_3') failReason = `èƒœåœºä¸è¶³ (${this.currentLevelWins}/3)`;
             else if (this.config.target === 'accumulate') failReason = `æ€»é‡‘å¸ä¸è¶³`;
        }

        if(this.config.target === 'accumulate') {
            if(pass) this.showSettlePanel(true, myRes, aiRes, finalPayout, cards, aiRes.cards, baitSrc, aiRes.t, fish, true, "", roundEarned);
            else if(this.currentRound < 3) this.showSettlePanel(win, myRes, aiRes, finalPayout, cards, aiRes.cards, baitSrc, aiRes.t, fish, false, "", roundEarned);
            else this.showFailPanel(myRes, aiRes, cards, aiRes.cards, failReason, roundEarned); // Pass round val
        } else {
             if (isEarlyExitLoss) {
                let earlyFailReason = `èƒœåœºä¸è¶³ (${this.currentLevelWins}/3)`;
                this.showFailPanel(myRes, aiRes, cards, aiRes.cards, earlyFailReason, roundEarned);
             } 
             else if (isEarlyExitWin) {
                this.showSettlePanel(true, myRes, aiRes, finalPayout, cards, aiRes.cards, baitSrc, aiRes.t, fish, true, "", roundEarned);
             }
             else if(this.currentRound < 3) {
                 this.showSettlePanel(win, myRes, aiRes, finalPayout, cards, aiRes.cards, baitSrc, aiRes.t, fish, false, "", roundEarned);
             }
             else if (pass) {
                 this.showSettlePanel(true, myRes, aiRes, finalPayout, cards, aiRes.cards, baitSrc, aiRes.t, fish, true, "", roundEarned);
             }
             else {
                 this.showFailPanel(myRes, aiRes, cards, aiRes.cards, failReason, roundEarned);
             }
        }
    }

    animateGold(target) {
        const el = document.getElementById('settle-gold-num');
        if(!el) return;
        let start = 0;
        const duration = 1500;
        const startTime = performance.now();
        const step = (now) => {
            const elapsed = now - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const ease = 1 - Math.pow(1 - progress, 3); 
            const current = Math.floor(start + (target - start) * ease);
            el.innerText = current;
            
            if(progress < 1 && Math.random() > 0.8) this.audio.playCoin();

            if(progress < 1) requestAnimationFrame(step);
            else el.innerText = target;
        };
        requestAnimationFrame(step);
    }

    // 3.0.2 Added levelVal (roundEarned) to args
    showSettlePanel(win, myRes, aiRes, gold, myCards, aiCards, mySrc, aiSrc, fish, isEnd, failMsg, levelVal) {
        const ov = document.getElementById('overlay-screen'); ov.classList.add('visible');
        this.setOverlayState(true);

        if(win) this.audio.playWin();
        else this.audio.playLose();

        const myTitle = win ? `${myRes.name} èƒœ` : `${myRes.name}`; const titleCls = win ? "win-title-tag" : "lose-title-tag";
        const getHTML = (cards) => { let h = ''; const allBait = [...this.playerBait, ...this.oppBait]; cards.forEach(c => { const isB = allBait.some(b => b.id === c.id); h += this.htmlCard(c, true, true, !!isB); }); return h; };
        
        // 3.0.2 Detail Split
        // Line 1: Hand + Type Bonus
        const row1 = myRes.row1;
        // Line 2: Items + Mults
        const row2 = myRes.row2;
        const itemsStr = myRes.items.length > 0 ? myRes.items.join(', ') : 'æ— ';
        // Line 3: Fishing
        const usedBait = mySrc==='mine'?this.playerBait:this.oppBait;
        const baitStr = usedBait.length>0 ? usedBait.map(c=>c.suit+c.rank).join(' ') : '';
        const baitTxt = mySrc==='mine' ? `ä½¿ç”¨é’“é±¼ç‰Œï¼šæˆ‘çš„é’“é¥µç‰Œ ${baitStr}` : (mySrc==='opp' ? `ä½¿ç”¨é’“é±¼ç‰Œï¼šå¯¹æ‰‹çš„é’“é¥µç‰Œ ${baitStr}` : 'æœªä½¿ç”¨é’“é±¼ç‰Œ');
        
        // Total Gold Logic for Display (before 10% cut, after fish mult)
        // myRes.payout is (Row1 + Row2). Fish applies to this sum.
        const totalWithFish = fish ? (myRes.payout * 2) : 0;
        const fishTxt = fish ? `<span style="color:var(--highlight)">é’“é±¼æˆåŠŸx2 + é‡‘å¸${myRes.payout}</span>` : 'æ— é’“é±¼å¥–åŠ±';
        
        // Level Progress Text
        const progressTxt = this.config.target === 'accumulate' ? `<div style="text-align:right; font-size:12px; color:#aaa; margin-top:5px;">æœ¬å…³è¿›åº¦: ${Math.floor(this.levelEarnedGold)}/${this.currentTargetGold}</div>` : '';

        if(isEnd && this.levelIndex >= LEVEL_CONFIG.length - 1 && win) { ov.innerHTML = `<div style="text-align:center; color:gold;"><div style="font-size:60px;">ğŸ¦Š</div><h1>æ— å°½å¡”æ¥¼ï¼ŒæŒ‘æˆ˜æˆåŠŸ</h1><p>æ­å–œè·å¾—ç‹ç‹¸å¾½ç« </p><button class="btn btn-primary" style="width:200px; margin-top:20px;" onclick="game.returnToLobby()">è¿”å›å¤§å…</button></div>`; return; }

        const pickCount = this.config.rewardPick || 3; const getCount = this.config.rewardGet || 1;
        let nextAction = isEnd ? `game.pickRewardPhase(${pickCount}, ${getCount})` : "game.nextRound()"; let btnTxt = isEnd ? "é¢†å–å¥–åŠ±" : "ä¸‹ä¸€å›åˆ";

        let tagsHTML = ''; 
        if(win) { 
            tagsHTML += `<div class="score-tag tag-win" style="opacity:1; transform:scale(1);">${myRes.name} èƒœ</div>`; 
            if(fish) tagsHTML += `<div class="score-tag tag-fish" style="opacity:1; transform:scale(1);">ğŸ£ é’“é±¼ x2</div>`; 
            this.passives.forEach(p => { 
                if(p.trigger === myRes.name || p.trigger === 'odd' || p.trigger === 'even' || p.trigger === 'face') { 
                   tagsHTML += `<div class="score-tag tag-skill" style="opacity:1; transform:scale(1);">${p.icon} ${p.name}</div>`; 
                }
            }); 
        }
        
        ov.innerHTML = `
        <div class="settle-modal">
            <div class="settle-header"><div>${win?'VICTORY':'MATCH RESULT'}</div><div class="multiplier-bar" style="font-size:16px;">æœ¬å±€è·å¾—ï¼šğŸ’° <span id="settle-gold-num">0</span></div></div>
            <div class="settle-content">
                <div class="settle-left"><div class="avatar" style="background-image: url('https://api.dicebear.com/7.x/bottts/svg?seed=${this.opponentName}')"></div><div class="result-badge">${aiRes.name}</div><div class="cards-display-row">${getHTML(aiCards)}</div><div style="font-size:10px; color:#666;">å¯¹æ‰‹æœ€ç»ˆç‰Œå‹</div></div>
                <div class="settle-right">
                    <div class="${titleCls}" style="display:flex; justify-content:space-between; width:100%; align-items:center;">
                        <span>${myTitle}</span>
                        ${progressTxt}
                    </div>
                    <div class="cards-display-row" style="transform:scale(1.1); margin:15px 0;">${getHTML(myCards)}</div>
                    <div style="width:100%; margin-top:10px; display:flex; flex-direction:column; gap:5px;">
                        <div class="detail-row">
                            <span>æˆ‘çš„ç‰Œå‹ï¼š${myRes.name}</span>
                            <span class="gold-val">é‡‘å¸ +${row1}</span>
                        </div>
                        <div class="detail-row" style="background:rgba(255,255,255,0.03);">
                            <span>é“å…·åŠ å€ï¼š${itemsStr}</span>
                            <span class="gold-val">é‡‘å¸ +${Math.floor(row2)}</span>
                        </div>
                        <div class="detail-row" style="background:rgba(255,255,255,0.03);">
                            <span style="font-size:12px; color:#888; max-width:50%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${baitTxt}</span>
                            <span>${fishTxt}</span>
                        </div>
                    </div>
                    <div class="tags-container" style="flex-wrap:wrap; opacity:1;">${tagsHTML}</div>
                </div>
            </div>
            <div class="settle-footer"><button class="btn btn-primary" style="width:200px; margin:0 auto;" onclick="${nextAction}">${btnTxt}</button></div>
        </div>`;

        if(win) this.animateGold(gold);
    }

    showFailPanel(myRes, aiRes, myCards, aiCards, reason, levelVal) { 
        this.audio.playLose();
        this.setOverlayState(true);
        const ov = document.getElementById('overlay-screen'); 
        ov.classList.add('visible');

        const getHTML = (cards) => cards.map(c => this.htmlCard(c, true, true, false)).join('');

        // 3.0.2 Left side progress display logic
        let leftInfo = `<div style="color:#e74c3c; font-weight:bold; text-align:center; font-size:14px; background:rgba(0,0,0,0.3); padding:10px; border-radius:4px; width:100%;">${reason}</div>`;
        
        // Add specific x/n progress if accumulation level
        if (this.config.target === 'accumulate') {
             leftInfo += `<div style="margin-top:10px; color:#aaa; font-size:12px;">æœ¬å±€: ${Math.floor(levelVal)} / ç´¯è®¡: ${Math.floor(this.levelEarnedGold)}/${this.currentTargetGold}</div>`;
        }

        ov.innerHTML = `
        <div class="settle-modal" style="border-color:var(--danger)">
            <div class="settle-header" style="background:#400;">DEFEAT</div>
            <div class="settle-content">
                <div class="settle-left" style="justify-content:center; gap:20px;">
                    <h2 style="color:var(--danger); font-size:24px; text-align:center; line-height:1.4;">ç­‰ç€å§ï½<br>æˆ‘ä¼šèµ¢å›æ¥çš„ï¼</h2>
                    ${leftInfo}
                </div>
                <div class="settle-right" style="justify-content:flex-start; gap:15px;">
                    <div style="text-align:center;">
                        <div style="font-size:12px; color:#aaa; margin-bottom:5px;">å¯¹æ‰‹: ${aiRes.name}</div>
                        <div class="cards-display-row">${getHTML(aiCards)}</div>
                    </div>
                    <div style="text-align:center; border-top:1px solid rgba(255,255,255,0.1); padding-top:15px;">
                        <div style="font-size:12px; color:#888; margin-bottom:5px;">æˆ‘çš„: ${myRes.name}</div>
                        <div class="cards-display-row">${getHTML(myCards)}</div>
                    </div>
                </div>
            </div>
            <div class="settle-footer">
                <button class="btn btn-primary" style="width:200px; margin:0 auto;" onclick="game.showFailScreen()">ç¡®å®š</button>
            </div>
        </div>`;
    }
    showFailScreen() { const ov = document.getElementById('overlay-screen'); ov.innerHTML = `<div class="msg-screen-content"><div class="msg-title">æŒ‘æˆ˜å¤±è´¥</div><div class="msg-subtitle">æ— å°½å¡”æ¥¼çš„è¯•ç‚¼è¿˜åœ¨ç»§ç»­...</div><button class="btn btn-lobby" onclick="game.returnToLobby()">å›åˆ°å¤§å…</button></div>`; }
    
    pickRewardPhase(pickCount, getCount) {
        this.setOverlayState(true);
        this.pendingPicks = getCount; const ov = document.getElementById('overlay-screen');
        let html = `<div style="text-align:center"><h2 style="color:var(--gold-color); margin-bottom:20px;">é€‰æ‹©æˆ˜åˆ©å“ (${pickCount} é€‰ ${getCount})</h2><div class="reward-container">`;
        const pool = [...REWARD_POOL]; const rw = [];
        const available = pool.filter(i => {
            if (i.unique && this.obtainedItems.includes(i.id)) return false;
            if (i.type === 'upgrade' && ['yunyan','xuanshu','huance'].includes(i.id) && this.upgradeCounts[i.id] >= 2) return false;
            return true;
        });
        for(let i=0; i<pickCount; i++) { if(!available.length) break; rw.push(available.splice(Math.floor(Math.random()*available.length),1)[0]); }
        rw.forEach((r,i) => { const icon = r.icon || 'ğŸ”°'; html += `<div class="reward-card" id="rcard-${i}" onclick="game.selectReward(${i}, this)"><div style="font-size:40px; margin-bottom:10px;">${icon}</div><div style="color:var(--highlight); font-weight:bold; margin-bottom:10px;">${r.name}</div><div style="font-size:13px; color:#ccc;">${r.desc}</div><input type="hidden" id="rw_${i}" value='${JSON.stringify(r)}'></div>`; });
        html += `</div></div>`; ov.innerHTML = html;
    }
    selectReward(idx, el) {
        const r = JSON.parse(document.getElementById('rw_'+idx).value);
        if(r.unique) this.obtainedItems.push(r.id);
        if(r.type === 'upgrade') {
            if(r.id === 'yunyan') { this.skillMaxModifiers.yundu += 1; this.skillUsage.yundu += 1; this.upgradeCounts.yunyan = (this.upgradeCounts.yunyan||0)+1; }
            else if(r.id === 'xuanshu') { this.skillMaxModifiers.xuanji += 1; this.skillUsage.xuanji += 1; this.upgradeCounts.xuanshu = (this.upgradeCounts.xuanshu||0)+1; }
            else if(r.id === 'huance') { if(this.betRatios[0] === 0.3) this.betRatios = [0.4, 0.6]; else if(this.betRatios[0] === 0.4) this.betRatios = [0.5, 0.7]; this.upgradeCounts.huance = (this.upgradeCounts.huance||0)+1; }
            else if(r.id === 'xinyu') { this.maxSlots++; }
        } else if (r.type === 'item_active') { if(!this.activeSkills.includes(r.ref)) { this.activeSkills.push(r.ref); const s = SKILLS_DB[r.ref]; this.skillUsage[r.ref] = s.maxUses; } } 
        else { this.passives.push(r); }
        el.style.border = '2px solid var(--gold-color)'; el.style.opacity = '0.5'; el.onclick = null;
        this.pendingPicks--;
        if(this.pendingPicks <= 0) { setTimeout(() => { 
            if (this.config.boss) { const ov = document.getElementById('overlay-screen'); const nextFloor = this.config.floor + 1; ov.innerHTML = `<div class="msg-screen-content"><div class="msg-title success">æ­å–œçˆ¬æ¥¼æˆåŠŸ</div><div class="msg-subtitle">å³å°†è¿›å…¥ ${nextFloor} å±‚æ¥¼</div><button class="btn btn-lobby" onclick="game.nextLevelAction()">å‰å¾€æŒ‘æˆ˜</button></div>`; } 
            else { game.nextLevelAction(); }
        }, 500); }
    }
    nextLevelAction() { 
        document.getElementById('overlay-screen').classList.remove('visible'); 
        this.setOverlayState(false);
        this.levelIndex++; 
        this.startLevel(); 
    }
    nextRound() { 
        document.getElementById('overlay-screen').classList.remove('visible'); 
        this.setOverlayState(false);
        this.currentRound++; 
        this.startRound(); 
    }

    activateSkill(k) { this.skillMode = k; this.selectedCards=[]; this.selectedOppCard = null; this.updateControls(); this.renderScene(); }
    cancelSkill() { this.skillMode=null; this.selectedCards=[]; this.selectedOppCard = null; this.updateControls(); this.renderScene(); }
    
    executeSkill() {
        const draw = (n) => { const c = []; 
            if (this.drawPile.length < n) {
                let fresh = this.createDeck();
                // v3.0.1 Naive replenish
                this.drawPile.push(...fresh);
            }
            if (this.drawPile.length < n && this.discardPile.length > 0) {
                 this.drawPile.push(...this.discardPile);
                 this.discardPile = [];
                 this.drawPile.sort(() => Math.random() - 0.5);
            }
            for(let i=0;i<n;i++) if(this.drawPile.length>0) c.push(this.drawPile.pop()); 
            return c; 
        };

        if(this.skillMode==='xuanji') {
            const n=this.selectedCards.length; const nc=draw(n); const selIds = this.selectedCards.map(c=>c.id);
            this.playerHand=this.playerHand.filter(x => !selIds.includes(x.id)); for(let c of nc) this.playerHand.push(c); 
            this.playerHand.sort((a,b)=>b.value-a.value); this.skillUsage.xuanji--;
            
            this.discardPile.push(...this.selectedCards);
            this.selectedCards = [...nc]; 
            this.renderScene();
            setTimeout(() => { this.selectedCards = []; this.renderScene(); }, 2000);

        } else if(this.skillMode==='yundu') {
            const m = this.selectedCards[0]; const r = Math.floor(Math.random() * this.oppHand.length); const t = this.oppHand[r];
            if(m && t) { 
                const pIdx = this.playerHand.findIndex(c => c.id === m.id); 
                if(pIdx > -1) { 
                    this.playerHand[pIdx] = t; this.oppHand[r] = m; 
                    
                    if (this.config.openHand || this.oppHand.some(c => c.revealed)) {
                        m.revealed = true;
                    } else {
                        m.revealed = false;
                    }

                    this.playerHand.sort((a,b)=>b.value-a.value); 
                    this.skillUsage.yundu--; 
                    
                    this.selectedCards = [t];
                    this.renderScene();
                    setTimeout(() => { this.selectedCards = []; this.renderScene(); }, 2000);
                } 
            }
        } else if (this.skillMode==='blast') {
            const mine = this.selectedCards[0]; const theirs = this.selectedOppCard;
            if(mine && theirs) { 
                const myIdx = this.playerHand.findIndex(c => c.id === mine.id); const oppIdx = this.oppHand.findIndex(c => c.id === theirs.id); 
                if (myIdx > -1 && oppIdx > -1) { 
                    this.playerHand[myIdx] = theirs; this.oppHand[oppIdx] = mine; 
                    
                    if (this.config.openHand || this.oppHand.some(c => c.revealed)) {
                        mine.revealed = true;
                    } else {
                        mine.revealed = false;
                    }

                    this.playerHand.sort((a,b)=>b.value-a.value); 
                    this.skillUsage.blast--; 

                    this.selectedCards = [theirs];
                    this.renderScene();
                    setTimeout(() => { this.selectedCards = []; this.renderScene(); }, 2000);
                } 
            }
        } else if (this.skillMode==='xinjing') {
            if(this.oppBait.length === 0) { const sort = [...this.oppHand].sort((a,b)=>a.value-b.value); this.oppBait = [sort[0], sort[1]]; this.oppHand = sort.slice(2); }
            this.oppBait.forEach(c => c.revealed = true); this.skillUsage.xinjing--; this.renderScene();
            this.cancelSkill();
        } else if (this.skillMode==='abyss') {
            this.oppHand.forEach(c => c.revealed = true); this.skillUsage.abyss--;
            this.cancelSkill();
        } else if (this.skillMode==='mirror') {
            this.playerHand = this.oppHand.map(c => new Card(c.suit, c.rank)); this.skillUsage.mirror--;
            this.cancelSkill();
        }
        
        if (['xuanji','yundu','blast'].includes(this.skillMode)) {
            this.skillMode = null; 
            this.selectedOppCard = null;
            this.updateControls();
        } else {
            this.cancelSkill();
        }
    }
    placeBet(idx) { const p = this.betRatios[idx]; const a=Math.floor(this.playerGold*p); this.playerGold-=a; this.currentBet+=a; this.betUsedThisRound = true; this.cancelSkill(); this.updateHeader(); }
    updateHeader() {
        document.getElementById('level-id').innerText = `FLOOR ${this.config.id}`;
        document.getElementById('gold-display').innerText = this.playerGold;
        const betDis = document.getElementById('bet-display');
        if(this.currentBet > 0) { betDis.style.display='block'; betDis.innerText = `ä¸‹æ³¨: ${this.currentBet}`; } else { betDis.style.display='none'; }
        const pl = document.getElementById('passive-list'); pl.innerHTML = '';
        this.passives.forEach(p => { const d = document.createElement('div'); d.className = 'passive-icon'; d.setAttribute('data-desc', `${p.name || ''}: ${p.desc}`); d.innerHTML = p.icon; pl.appendChild(d); });
        const g = document.getElementById('level-desc');
        let txt = "";
        if(this.config.target==='accumulate') { txt = `3å›åˆå†…é‡‘å¸ > <span class="gold-val">${Math.floor(this.levelEarnedGold)}/${this.currentTargetGold}</span> (${this.currentRound}/3å›åˆ)`; } 
        else { txt = this.config.desc; }
        g.innerHTML = txt;
    }
    toggleInfo() {
        const sc = document.getElementById('info-screen');
        if(sc.classList.contains('visible')) { 
            sc.classList.remove('visible'); 
            this.setOverlayState(false);
            return; 
        }
        
        this.setOverlayState(true);
        const ct = document.getElementById('info-content'); ct.innerHTML = '';
        
        const isDefault = !this.inGame; 

        HAND_TYPES_BASE.forEach(t => {
            let val = t.base; let act = false; let mult = 0;
            
            if (!isDefault) {
                this.passives.forEach(p=>{ 
                    if(p.trigger===t.name) { 
                        if (p.val) { val += p.val; act=true; }
                    } 
                    if(p.trigger===t.name && p.mult) { mult+=p.mult; } 
                });
            }

            ct.innerHTML += `<div class="info-row"><span>${t.name} <span style="font-size:10px; color:#666">(${t.en})</span></span><span style="${act?'color:var(--gold-color)':''}">${val}é‡‘å¸${act?'â†‘':''}</span><span style="${mult>0?'color:var(--rare)':''}">æŠ€èƒ½å€æ•°ï¼š${mult}</span></div>`;
        });
        sc.classList.add('visible');
    }
}
const game = new Game();
</script>
</body>
</html>