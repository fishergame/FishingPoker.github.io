<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Fishing Poker [v3.2.2] - Optimization & UI Updates</title>
    <style>
        /* ================= UI æ ·å¼ä¿æŒ v1.9.9 åŸºç¡€ ================= */
        :root {
            --bg-gradient: radial-gradient(circle at center, #1a202c 0%, #000000 100%);
            --card-width: 60px;
            --card-height: 86px;
            --mini-card-width: 48px;  
            --mini-card-height: 68px;
            
            --gold-color: #ffd700;
            --highlight: #00f2ff;
            --danger: #ff0055;
            --rare: #d580ff;
            --panel-bg: rgba(25, 25, 30, 0.95);
            --modal-bg: linear-gradient(180deg, #37475a 0%, #232d3a 100%);
        }

        @media (min-width: 768px) {
            :root { --card-width: 80px; --card-height: 112px; }
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; font-family: 'Segoe UI', sans-serif; }
        body { background: var(--bg-gradient); color: #fff; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }

        /* Splash Screen */
        #splash-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 300; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 1.5s ease-in-out; pointer-events: auto; }
        .splash-logo { width: 120px; height: 120px; fill: #fff; margin-bottom: 20px; filter: drop-shadow(0 0 10px rgba(255,255,255,0.5)); }
        .splash-text { font-family: 'Segoe UI Light', sans-serif; font-weight: 100; font-size: 24px; letter-spacing: 8px; color: #fff; opacity: 0.8; }
        .fade-out { opacity: 0 !important; pointer-events: none; }

        /* Lobby */
        #lobby-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(180deg, #050a14 0%, #000000 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; overflow: hidden; transition: opacity 0.5s; }
        .waves-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 40vh; pointer-events: none; z-index: 1; opacity: 0.3; }
        .waves { width: 100%; height: 100%; min-height: 100px; max-height: 250px; }
        .parallax > use { animation: move-wave 35s cubic-bezier(.55,.5,.45,.5) infinite; }
        .parallax > use:nth-child(1) { animation-duration: 45s; fill: rgba(0, 50, 100, 0.3); }
        .parallax > use:nth-child(2) { animation-duration: 30s; fill: rgba(0, 80, 150, 0.2); }
        .parallax > use:nth-child(3) { animation-duration: 20s; fill: rgba(0, 100, 200, 0.1); }
        @keyframes move-wave { 0% { transform: translate3d(-90px, 0, 0); } 100% { transform: translate3d(85px, 0, 0); } }
        .story-scroll { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; display: flex; justify-content: center; mask-image: linear-gradient(to bottom, transparent 10%, black 40%, black 60%, transparent 90%); -webkit-mask-image: linear-gradient(to bottom, transparent 10%, black 40%, black 60%, transparent 90%); }
        .story-content { width: 600px; color: rgba(220, 220, 220, 0.3); font-size: 16px; line-height: 2.2; text-align: center; font-family: 'Georgia', serif; font-style: italic; animation: scrollText 45s linear infinite; animation-delay: 2s; transform: translateY(100vh); }
        @keyframes scrollText { 0% { transform: translateY(100vh); } 100% { transform: translateY(-120%); } }
        .lobby-content { text-align: center; z-index: 10; position: relative; }
        .lobby-title-main { font-family: 'YouYuan', 'Microsoft YaHei', sans-serif; font-size: 64px; font-weight: 300; color: #fff; text-shadow: 0 0 15px var(--highlight); margin-bottom: 0; line-height: 1; letter-spacing: 5px; }
        .lobby-title-sub { font-family: 'YouYuan', 'Microsoft YaHei', sans-serif; font-size: 32px; font-weight: 100; color: var(--highlight); text-shadow: 0 0 10px rgba(0, 242, 255, 0.5); margin-top: 15px; letter-spacing: 8px; margin-bottom: 20px; }
        .lobby-orientation { font-family: 'YouYuan', 'Microsoft YaHei', sans-serif; font-size: 16px; color: rgba(255,255,255,0.6); letter-spacing: 4px; margin-bottom: 50px; }
        .btn-lobby { font-size: 20px; padding: 16px 60px; width: auto; background: linear-gradient(90deg, var(--highlight), #0099cc); color: #000; font-weight: 800; border:none; border-radius: 50px; box-shadow: 0 0 25px rgba(0, 242, 255, 0.4); cursor: pointer; transition: 0.3s; letter-spacing: 2px; }
        .btn-lobby:hover { transform: scale(1.05) translateY(-2px); box-shadow: 0 0 40px var(--highlight); }

        /* Map Screen */
        #map-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(180deg, #0e121b 0%, #000000 100%); z-index: 250; display: none; flex-direction: column; overflow: hidden; }
        #map-scroll-area { flex: 1; overflow-y: auto; padding: 40px 20px; display: flex; flex-direction: column-reverse; align-items: center; gap: 50px; scroll-behavior: smooth; }
        .map-title { text-align: center; padding: 25px; font-size: 28px; color: var(--highlight); letter-spacing: 3px; background: rgba(0,0,0,0.8); z-index: 2; border-bottom: 1px solid #333; font-family: 'YouYuan', sans-serif; }
        .floor-group { width: 100%; max-width: 450px; position: relative; border: 1px solid rgba(255,255,255,0.1); border-radius: 20px; padding: 25px; background: rgba(255,255,255,0.03); display: flex; flex-direction: column; align-items: center; gap: 20px; transition: 0.3s; }
        .floor-group:hover { border-color: rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); }
        .floor-label { position: absolute; top: -14px; left: 20px; background: #000; padding: 2px 12px; color: #666; font-size: 14px; font-weight: bold; border: 1px solid #444; border-radius: 10px; font-family: monospace; }
        .nodes-row { display: flex; justify-content: space-around; width: 100%; align-items: center; position: relative; }
        .map-node { width: 70px; height: 70px; border-radius: 50%; background-size: cover; background-position: center; border: 3px solid #444; position: relative; cursor: default; transition: 0.3s; box-shadow: 0 4px 10px rgba(0,0,0,0.5); z-index: 2; background-color: #222; }
        .map-node.locked { filter: grayscale(1) brightness(0.4); opacity: 0.6; }
        .map-node.active { border-color: var(--highlight); box-shadow: 0 0 25px rgba(0, 242, 255, 0.4); cursor: pointer; animation: pulse-node 2s infinite; transform: scale(1.05); filter: brightness(1.1); }
        .map-node.active:hover { transform: scale(1.15); box-shadow: 0 0 35px var(--highlight); }
        .map-node.cleared { border-color: var(--gold-color); filter: brightness(0.8); cursor: default; }
        .map-node.cleared::after { content: 'âœ“'; position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 32px; color: var(--gold-color); font-weight: bold; text-shadow: 0 0 5px black; }
        .map-node-label { position: absolute; bottom: -24px; left: 50%; transform: translateX(-50%); white-space: nowrap; font-size: 11px; color: #999; background: rgba(0,0,0,0.8); padding: 2px 6px; border-radius: 4px; font-weight: bold; }
        @keyframes pulse-node { 0% { box-shadow: 0 0 10px rgba(0, 242, 255, 0.3); } 50% { box-shadow: 0 0 25px rgba(0, 242, 255, 0.6); } 100% { box-shadow: 0 0 10px rgba(0, 242, 255, 0.3); } }
        .map-connector { flex: 1; height: 3px; background: #333; margin: 0 5px; position: relative; border-radius: 2px; }
        .map-connector.unlocked { background: linear-gradient(90deg, var(--gold-color), var(--highlight)); box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        
        /* Header */
        header { height: 60px; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; padding: 0 20px; background: rgba(0,0,0,0.9); border-bottom: 1px solid #333; z-index: 201; position:relative; transition: transform 0.3s ease-in-out; }
        body.overlay-active header { display: none; }
        .header-left { display: flex; flex-direction: column; transition: opacity 0.3s; }
        .level-id { font-size: 20px; color: var(--highlight); font-weight: 800; letter-spacing: 1px; }
        .level-goal { font-size: 12px; color: #bbb; margin-top: 2px; }
        .lobby-hide { opacity: 0; pointer-events: none; }
        .header-center { display: flex; gap: 12px; align-items: center; position: absolute; left: 50%; transform: translateX(-50%); }
        .icon-btn { width: 28px; height: 28px; background: #333; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; border: 1px solid #555; transition: 0.2s; color: #aaa; }
        .icon-btn:hover { border-color: var(--highlight); color: var(--highlight); box-shadow: 0 0 10px rgba(0, 242, 255, 0.2); }
        .icon-btn.active { color: var(--highlight); border-color: var(--highlight); box-shadow: 0 0 5px rgba(0, 242, 255, 0.3); animation: pulse-audio 2s infinite; }
        .icon-btn svg { width: 14px; height: 14px; fill: currentColor; }
        @keyframes pulse-audio { 0% { box-shadow: 0 0 5px rgba(0, 242, 255, 0.3); } 50% { box-shadow: 0 0 15px rgba(0, 242, 255, 0.5); } 100% { box-shadow: 0 0 5px rgba(0, 242, 255, 0.3); } }
        .header-right { display: flex; gap: 15px; align-items: center; transition: opacity 0.3s; }
        
        .passive-dock { display: flex; gap: 5px; max-width: 220px; overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
        .passive-dock::-webkit-scrollbar { display: none; }
        .passive-icon { width: 28px; height: 28px; background: #2d3748; border: 1px solid var(--rare); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 16px; cursor: help; color: var(--rare); position: relative; flex-shrink: 0; transition: transform 0.2s; }
        .passive-icon:hover { transform: scale(1.1); box-shadow: 0 0 10px var(--rare); z-index: 10; cursor: pointer; }

        .gold-container { display: flex; align-items: center; gap: 10px; }
        .bet-info { font-size: 12px; color: #ff9f43; font-weight: bold; animation: pulse 1s infinite; display: none; }
        .gold-pill { color: var(--gold-color); font-weight: bold; font-size: 16px; background: rgba(255, 215, 0, 0.1); padding: 5px 12px; border-radius: 4px; border: 1px solid rgba(255, 215, 0, 0.3); }
        .gold-val { color: var(--gold-color); font-weight: bold; }
        
        #main-stage { flex: 1; display: flex; padding: 20px; gap: 20px; overflow: hidden; align-items: stretch; }
        .panel { background: var(--panel-bg); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; display: flex; flex-direction: column; align-items: center; padding: 15px; position: relative; }
        .panel-title { font-size: 12px; text-transform: uppercase; color: #888; letter-spacing: 1px; width: 100%; text-align: center; margin-bottom: 10px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        #left-panel { flex: 0 0 220px; justify-content: flex-start; position: relative;}
        .avatar { width: 70px; height: 70px; border-radius: 50%; border: 3px solid #555; background: #222 center/cover; margin-bottom: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.5); transition: background-image 0.5s;}
        
        .opp-speech { position: absolute; left: 170px; top: 70px; width: auto; max-width: 250px; min-width: 150px; height: auto; background: rgba(0,0,0,0.9); border: 1px solid var(--highlight); border-radius: 10px; padding: 10px; color: #fff; font-size: 12px; line-height: 1.4; opacity: 0; pointer-events: none; z-index: 50; box-shadow: 0 5px 15px rgba(0,0,0,0.8); transition: opacity 0.5s; word-break: break-all; }
        .opp-speech::before { content: ''; position: absolute; top: 15px; left: -8px; width: 0; height: 0; border-top: 8px solid transparent; border-bottom: 8px solid transparent; border-right: 8px solid var(--highlight); }
        .opp-hand-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-top: 10px; }
        #center-panel { flex: 1; justify-content: space-between; }
        .baits-container { display: flex; flex-direction: column; gap: 20px; width: 100%; align-items: center; justify-content: center; flex: 1; }
        .bait-row { display: flex; gap: 15px; align-items: center; position: relative; justify-content: center; min-height: 90px; width: 100%; }
        .bait-label { position: static; width: auto; min-width: 60px; font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; text-align: right; margin-right: 10px; display: flex; flex-direction: column; justify-content: center; }
        .slot-placeholder { width: var(--card-width); height: var(--card-height); border: 2px dashed rgba(255,255,255,0.15); border-radius: 6px; background: rgba(0,0,0,0.2); }
        #player-hand-area { margin-top: auto; width: 100%; display: flex; justify-content: center; padding-top: 20px; border-top: 1px solid #444; height: 130px; }
        #hand-container { display: flex; gap: 8px; align-items: flex-end; }
        #right-panel { flex: 0 0 240px; justify-content: space-between; padding-bottom: calc(15px + env(safe-area-inset-bottom)); }
        .action-area { width: 100%; display: flex; flex-direction: column; gap: 10px; flex: 1; }
        #skill-dock { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 20px; padding-top: 10px; border-top: 1px solid #444; }
        
        .card-deal-anim { animation: cardDeal 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) backwards; }
        @keyframes cardDeal { 0% { transform: translateY(-50px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }

        .card { background: #f0f0f0; border-radius: 6px; position: relative; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); width: var(--card-width); height: var(--card-height); overflow: hidden; }
        .card.mini { width: var(--mini-card-width); height: var(--mini-card-height); font-size: 0.8em;}
        .card.red { color: #e74c3c; } .card.black { color: #2c3e50; }
        .card-rank { position: absolute; top: 4px; left: 6px; font-size: 1.4em; font-weight: 800; line-height: 1; }
        .card-suit { position: absolute; top: 55%; left: 50%; transform: translate(-50%, -50%); font-size: 2.5em; line-height: 1; }
        .card-back { background: #34495e; border: 2px solid #7f8c8d; display: flex; align-items: center; justify-content: center; }
        .card-back::after { content: ''; width: 70%; height: 70%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" fill="none" stroke="%2394a3b8" stroke-width="5"><path d="M20,30 L50,80 L80,30 L90,10 L50,30 L10,10 Z" /></svg>'); background-repeat: no-repeat; background-position: center; opacity: 0.3; }

        .card:hover { transform: translateY(-5px); z-index: 10; }
        .card.selected { transform: translateY(-15px); box-shadow: 0 0 15px var(--highlight); border: 2px solid var(--highlight); z-index: 10; }
        .card.opp-selected { transform: translateY(-15px); box-shadow: 0 0 15px var(--danger); border: 2px solid var(--danger); z-index: 10; }
        .badge-bait { position: absolute; top:0; right:0; background:#333; color:#fff; font-size:9px; padding:1px 3px; z-index:2;}
        
        .btn { background: linear-gradient(145deg, #2c3e50, #1a252f); border: 1px solid #4a5c6a; color: #fff; padding: 12px 5px; border-radius: 4px; cursor: pointer; transition: 0.2s; font-size: 13px; text-align: center; position: relative; width: 100%; box-shadow: 0 2px 5px rgba(0,0,0,0.3); user-select: none; -webkit-tap-highlight-color: transparent; }
        .btn:active { transform: scale(0.95); }
        .btn:hover:not(:disabled) { border-color: var(--highlight); box-shadow: 0 0 15px rgba(0, 242, 255, 0.5); background: #34495e; }
        .btn-primary { background: linear-gradient(145deg, #2980b9, #2c3e50); border: 1px solid #3498db; }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; transform: none; }
        .btn-desc { display: block; font-size: 10px; opacity: 0.7; margin-top: 2px; }
        
        .skill-item { aspect-ratio: 3/4; background: #34495e; border-radius: 4px; border: 1px solid #566573; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; position: relative; transition: 0.2s; }
        .skill-item:hover:not(.disabled) { border-color: var(--highlight); box-shadow: 0 0 10px var(--highlight); }
        .skill-item.disabled { filter: grayscale(1); opacity: 0.3; cursor: default; }
        .skill-count { position: absolute; bottom: 2px; right: 2px; font-size: 9px; background: #000; padding: 1px 3px; border-radius: 3px; }
        
        .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; z-index: 400; opacity: 0; pointer-events: none; transition: 0.3s; }
        .overlay.visible { opacity: 1; pointer-events: all; }
        
        .settle-modal { width: 90%; max-width: 750px; background: var(--modal-bg); border-radius: 12px; box-shadow: 0 0 50px rgba(0,0,0,0.8); border: 1px solid #4a5c6a; overflow: hidden; display: flex; flex-direction: column; max-height: 90vh; }
        .settle-header { background: rgba(0,0,0,0.3); padding: 8px 15px; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: space-between; align-items: center; color: #fff; flex-shrink: 0; }
        .multiplier-bar { display: flex; gap: 10px; align-items: center; font-family: monospace; font-size: 16px; color: var(--gold-color);}
        
        .settle-content { display: flex; min-height: 200px; flex: 1; overflow-y: auto; }
        .settle-left { width: 35%; background: rgba(0,0,0,0.2); padding: 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; border-right: 1px solid rgba(255,255,255,0.1); gap: 10px; }
        .settle-right { width: 65%; padding: 20px; display: flex; flex-direction: column; justify-content: center; gap: 15px; }
        
        .result-badge { background: #333; padding: 2px 10px; font-size: 12px; color: #aaa; margin-bottom: 5px; }
        .win-title-tag { align-self: center; background: linear-gradient(90deg, #d35400, #e67e22); color: white; font-weight: bold; font-size: 20px; padding: 5px 25px; border-radius: 4px; box-shadow: 0 0 15px rgba(230, 126, 34, 0.6); margin-bottom: 10px; }
        .lose-title-tag { align-self: center; background: #555; color: #aaa; font-weight: bold; font-size: 20px; padding: 5px 25px; border-radius: 4px; margin-bottom: 10px; }
        .cards-display-row { display: flex; justify-content: center; gap: 8px; margin: 5px 0; flex-wrap: wrap; }
        .detail-row { display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 4px; font-size: 14px; }
        .detail-sub { font-size: 12px; color: #888; display: flex; gap: 10px; align-items: center;}
        
        .settle-footer { padding: 15px; background: rgba(0,0,0,0.4); text-align: center; border-top: 1px solid rgba(255,255,255,0.1); flex-shrink: 0; }
        .tags-container { margin-top: 5px; display: flex; flex-direction: row; flex-wrap: wrap; justify-content: flex-start; gap: 8px; align-items: center; }
        
        .score-tag { background: #333; border: 1px solid #555; padding: 4px 12px; border-radius: 20px; font-size: 12px; display: flex; align-items: center; gap: 5px; }
        .tag-win { background: linear-gradient(90deg, #f1c40f, #f39c12); color: #fff; font-weight: bold; border: none; }
        .tag-fish { border:1px solid var(--highlight); color: #fff; font-weight: bold; }
        
        .reward-card { background: #2d3748; border: 2px solid #4a5568; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; transition: 0.3s; box-shadow: 0 4px 15px rgba(0,0,0,0.5); position:relative;}
        .reward-card:hover { transform: scale(1.05); border-color: var(--rare); box-shadow: 0 0 25px rgba(213, 128, 255, 0.4); }
        
        .info-panel { background: #1a1a1a; border: 1px solid #555; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; color: #ddd; box-shadow: 0 0 30px black; }
        .info-title { color: var(--highlight); margin-bottom: 5px; text-align: center; font-size: 18px; font-weight: bold; }
        .info-desc { font-size: 12px; color: #888; text-align: center; margin-bottom: 20px; }
        .info-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #333; font-size: 14px; }
        .info-row span { flex: 1; text-align: center; }
        .info-row span:first-child { text-align: left; }
        .info-row span:last-child { text-align: right; }
        .msg-screen-content { text-align: center; color: #fff; }
        .msg-title { font-size: 40px; font-weight: 800; margin-bottom: 20px; color: var(--danger); text-shadow: 0 0 20px rgba(0,0,0,0.8); }
        .msg-subtitle { font-size: 18px; color: #ccc; margin-bottom: 40px; }
        
        #global-tooltip { position: fixed; background: rgba(0,0,0,0.95); padding: 10px 15px; font-size: 12px; line-height: 1.5; border: 1px solid #666; border-radius: 6px; color: #fff; box-shadow: 0 5px 20px rgba(0,0,0,0.9); z-index: 9999; pointer-events: none; display: none; max-width: 220px; white-space: pre-wrap; }

        /* Fullscreen Shop & Inventory UI (v3.2.2) */
        #shop-screen { position: fixed; inset: 0; background: var(--bg-gradient); z-index: 450; display: none; flex-direction: row; width: 100%; height: 100%; overflow: hidden; }
        #shop-inv-left { width: 40%; border-right: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.4); display: flex; flex-direction: column; position: relative; }
        #shop-inv-right { width: 60%; background: rgba(0,0,0,0.2); display: flex; flex-direction: column; }
        
        .shop-tab { padding: 15px 30px; cursor: pointer; color: #aaa; font-weight: bold; transition: 0.3s; }
        .shop-tab.active { color: #fff; background: rgba(255,255,255,0.1); border-bottom: 2px solid var(--highlight); }
        .pack-card { background: linear-gradient(145deg, #2d3748, #1a202c); border: 2px solid #4a5568; border-radius: 12px; padding: 30px 20px; text-align: center; cursor: pointer; transition: 0.3s; flex: 1; min-width: 140px; }
        .pack-card:hover { transform: translateY(-5px); border-color: var(--gold-color); box-shadow: 0 10px 20px rgba(0,0,0,0.5); }
        
        /* Removed translation/scaling on hover to avoid misalignment issues on active slots */
        #equip-circle-wrapper { transition: transform 0.3s ease; transform-origin: center center; }
        .equip-slot { position: absolute; left: 50%; top: 50%; width: 44px; height: 44px; border-radius: 50%; background: #1a1a1a; border: 2px dashed #555; display: flex; align-items: center; justify-content: center; font-size: 20px; cursor: pointer; transition: 0.2s; z-index: 2; box-shadow: inset 0 0 10px rgba(0,0,0,0.8); transform: translate(-50%, -50%); }
        .equip-slot.filled { border-style: solid; border-color: var(--highlight); background: #2d3748; }
        .equip-slot.normal { border-color: var(--rare); }
        .equip-slot:hover { border-color: #fff; z-index: 10; box-shadow: 0 0 15px rgba(255,255,255,0.5), inset 0 0 10px rgba(0,0,0,0.8); }

        .inv-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; padding-bottom: 20px;}
        .inv-item { background: #2d3748; border: 1px solid #4a5568; border-radius: 8px; padding: 10px; text-align: center; cursor: pointer; aspect-ratio: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; transition: 0.2s;}
        .inv-item:hover { border-color: var(--highlight); box-shadow: 0 0 10px var(--highlight); }
        .inv-item.equipped { border-color: var(--highlight); }
        .inv-item.equipped::after { content: 'å·²è£…å¤‡'; position: absolute; top: 0; right: 0; background: var(--highlight); color: #000; font-size: 9px; padding: 2px 4px; border-radius: 0 8px 0 4px; }

        /* Fullscreen Tutorial Screen (v3.2.2) */
        #tutorial-screen { position: fixed; inset: 0; background: #000; display: none; justify-content: center; align-items: center; z-index: 500; }
        #tutorial-screen.visible { display: flex; }
        .envelope-container { width: 90%; max-width: 800px; padding: 20px; }
        .letter-modal {
            position: relative; width: 100%; background: rgba(18, 22, 30, 0.98); border: 2px solid var(--gold-color); border-radius: 4px;
            padding: 60px 40px 40px; box-shadow: 0 0 50px rgba(0,0,0,0.8); font-family: 'Times New Roman', serif; color: #d1d5db; line-height: 1.8;
        }
        .letter-modal::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 80px; background: rgba(255, 215, 0, 0.05);
            border-bottom: 2px solid var(--gold-color); clip-path: polygon(0 0, 100% 0, 50% 100%); pointer-events: none;
        }
        .letter-stamp {
            position: absolute; top: 15px; right: 25px; width: 50px; height: 60px; background: #a93226; border: 2px dashed #f2d7d5;
            color: #fff; font-size: 24px; font-family: 'YouYuan', sans-serif; display: flex; align-items: center; justify-content: center;
            transform: rotate(15deg); box-shadow: 2px 2px 5px rgba(0,0,0,0.5); pointer-events: none;
        }
        .letter-header { font-size: 32px; font-weight: bold; color: var(--gold-color); margin-bottom: 25px; text-align: center; padding-bottom: 15px; font-family: 'YouYuan', serif; }
        .letter-body { font-size: 15px; margin-bottom: 30px; text-align: justify; }
        .letter-body b { color: var(--highlight); }
        .letter-footer { display: flex; justify-content: center; }
        .hl-txt { color: var(--highlight); font-weight: bold; }

        @media (max-width: 768px) {
            .settle-modal { width: 95%; max-width: 400px; }
            .settle-content { flex-direction: column; }
            .settle-left, .settle-right { width: 100%; border-right: none; border-bottom: 1px solid rgba(255,255,255,0.1); padding: 15px; }
            .settle-right { border-bottom: none; }
            .win-title-tag, .lose-title-tag { font-size: 18px; padding: 4px 20px; }
            .cards-display-row { transform: scale(0.9); margin: 0; }
            
            /* v3.2.2 Mobile Card adjustments for harmony */
            .card-rank { font-size: 1.2em !important; font-weight: normal !important; top: 3px !important; left: 5px !important; }
            .card-suit { font-size: 1.4em !important; }
            .card.mini .card-rank { font-size: 0.9em !important; font-weight: normal !important; top: 2px !important; left: 4px !important; }
            .card.mini .card-suit { font-size: 1.1em !important; }
            
            /* v3.2.2 Mobile Shop Responsive */
            #shop-screen { flex-direction: column; }
            #shop-inv-left { width: 100% !important; height: 35vh !important; border-right: none !important; border-bottom: 1px solid rgba(255,255,255,0.1); flex: none; }
            #shop-inv-right { width: 100% !important; height: 65vh !important; flex: 1; }
            #equip-circle-wrapper { transform: scale(0.65); }
        }

        @media screen and (max-height: 600px) and (orientation: landscape) {
            :root { --card-width: 40px; --card-height: 56px; --mini-card-width: 32px; --mini-card-height: 44px; }
            
            /* v3.2.2 Landscape Card adjustments */
            .card-rank { font-size: 1.0em !important; font-weight: normal !important; top: 2px !important; left: 4px !important; }
            .card-suit { font-size: 1.2em !important; top: 55% !important; } 
            .card.mini .card-rank { font-size: 0.8em !important; font-weight: normal !important; top: 1px !important; left: 3px !important; }
            .card.mini .card-suit { font-size: 1.0em !important; top: 58% !important; }
            
            .info-panel { width: 90%; max-height: 85vh; overflow-y: auto; font-size: 10px; padding: 10px; }
            .lobby-title-main { font-size: 40px; letter-spacing: 2px; }
            .lobby-title-sub { font-size: 20px; margin-bottom: 10px; letter-spacing: 2px; }
            .lobby-orientation { font-size: 12px; margin-bottom: 20px; letter-spacing: 2px; }
            .btn-lobby { font-size: 16px; padding: 10px 30px; }
            .story-content { font-size: 14px; width: 80%; }
            header { height: 40px; padding: 0 10px; }
            .level-id { font-size: 16px; }
            .level-goal { font-size: 10px; }
            .info-btn { padding: 4px 8px; font-size: 10px; }
            .gold-pill { font-size: 12px; padding: 3px 8px; }
            #main-stage { padding: 5px; gap: 8px; }
            #left-panel { flex: 0 0 130px; padding: 8px; }
            .avatar { width: 50px; height: 50px; margin-bottom: 5px; }
            .opp-hand-grid { gap: 4px; }
            .panel-title { font-size: 10px; margin-bottom: 5px; padding-bottom: 2px; }
            .opp-speech { left: 110px; top: 25px; width: auto; max-width: 200px; font-size: 10px; padding: 6px; border-radius: 8px; }
            #right-panel { flex: 0 0 160px; padding: 8px; padding-bottom: calc(8px + env(safe-area-inset-bottom)); }
            .btn { padding: 8px 2px; font-size: 10px; }
            #skill-dock { margin-top: 5px; padding-top: 5px; gap: 4px; }
            .skill-item div:first-child { font-size: 16px; } 
            .skill-item div:nth-child(2) { font-size: 9px; transform: scale(0.9); }
            #center-panel { padding: 5px; }
            .baits-container { gap: 5px; }
            .bait-row { min-height: 60px; gap: 8px; }
            .bait-label { min-width: 40px; font-size: 10px; margin-right: 5px; }
            .slot-placeholder { border-width: 1px; border-radius: 4px; }
            #player-hand-area { height: 70px; padding-top: 10px; }
            .settle-modal { max-height: 95vh; overflow-y: auto; }
            .settle-header { padding: 8px 15px; font-size: 16px; }
            .settle-content { flex-direction: row; min-height: auto; }
            .settle-left { width: 30%; padding: 10px; gap: 5px; }
            .settle-right { width: 70%; padding: 10px; gap: 10px; }
            .win-title-tag, .lose-title-tag { font-size: 16px; padding: 4px 15px; }
            .detail-row { padding: 8px; }
            .msg-title { font-size: 28px; }
            .msg-subtitle { font-size: 14px; margin-bottom: 20px; }
            
            #shop-inv-left { width: 35% !important; }
            #shop-inv-right { width: 65% !important; }
            #equip-circle-wrapper { transform: scale(0.65); }
        }
    </style>
</head>
<body>

<div id="splash-screen">
    <svg class="splash-logo" viewBox="0 0 100 100">
        <path d="M20,80 Q35,60 50,80 T80,80" fill="none" stroke="white" stroke-width="8" stroke-linecap="round" />
        <path d="M20,50 Q35,30 50,50 T80,50" fill="none" stroke="white" stroke-width="8" stroke-linecap="round" />
        <path d="M20,20 Q35,0 50,20 T80,20" fill="none" stroke="white" stroke-width="8" stroke-linecap="round" />
    </svg>
    <div class="splash-text">FISHER GAME</div>
</div>

<!-- New: Level Map Screen -->
<div id="map-screen">
    <div class="map-title">æ— å°½å¡”æ¥¼</div>
    <div id="map-scroll-area">
        <!-- Floors injected by JS -->
    </div>
</div>

<div id="lobby-screen">
    <div class="waves-container">
        <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
            <defs> <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" /> </defs>
            <g class="parallax">
                <use xlink:href="#gentle-wave" x="48" y="0" />
                <use xlink:href="#gentle-wave" x="48" y="3" />
                <use xlink:href="#gentle-wave" x="48" y="5" />
            </g>
        </svg>
    </div>
    <div class="story-scroll">
        <div class="story-content">
            çå¼€çœ¼ï¼Œå·²ç»åˆ°äº†æ¸¯å£<br>
            çˆ·çˆ·åœ¨æˆ‘è¢«èµ¶ä¸‹èˆ¹å‰ï¼Œå¡ç»™æˆ‘äº†ä¸€ä¸ªå®ç›’ï¼Œä¸€ä¸ªé”¦å›Šï¼Œè®©æˆ‘ä¸€å®šå¸¦å¥½ï¼Œå®ƒä¼šç»™æˆ‘å¥½è¿<br>
            å¥½å¤å¤çš„è¢‹å­ï¼Œé‡Œé¢è£…ç€ä¸€å¼ å¡ç‰‡ï¼Œçœ‹èµ·æ¥ï¼Œæœ‰äº›å¹´å¤´ã€‚<br>
            çˆ·çˆ·è¯´ï¼Œå®çŸ³æ— è®ºå¦‚ä½•åˆ«æ‹¿å‡ºæ¥ï¼Œåªç®¡å¸¦ç€å°±å¥½ã€‚è€Œé•œå›Šï¼Œåœ¨å±æœºæ—¶åˆ»ï¼Œå¯ä»¥å¸®æˆ‘ã€‚<br>
            æˆ‘ç‚¹äº†ç‚¹å¤´ï¼Œåˆçœ‹äº†çœ¼å®ç›’ï¼Œé‡Œé¢è£…ç€çš„å®çŸ³äº®ç€ç´«è‰²ï¼Œå…‰èŠ’è€€çœ¼ï¼Œæˆ‘ç«‹é©¬åˆä¸Šå®ç›’ã€‚<br>
            åœ¨å–‡å­çš„å‚¬ä¿ƒä¸‹ï¼Œéšç€äººç¾¤èµ°ä¸‹èˆ¹ã€‚<br>
            è¿™é‡Œæ˜¯ä»–ä»¬å£ä¸­è¯´çš„ï¼Œå¾é€”é‡Œçš„ç¬¬ä¸€å²›ï¼šç‹ç‹¸å²›ï¼Œéš¾åº¦ç³»æ•°è¾¾4æ˜ŸåŠï¼›éƒ½æ²¡åˆ°åŠæ ¼çš„6æ˜Ÿï¼Œ<br>
            å´æ˜¯è®©æœ€å¤šäººå€’ä¸‹çš„åœ°æ–¹ï¼Œç”šè‡³æœ‰ä¼ è¨€è¿™é‡Œç»å¸¸æœ‰äººå¤±è¸ªï¼Œå¿˜äº†å›å®¶çš„è·¯ã€‚<br>
            è°çŸ¥é“å‘¢ï¼Œæˆ–è®¸æˆä¸ºå¤§äººçš„è·¯ä¸Šï¼Œéƒ½æ˜¯éš¾å…çš„ï¼Ÿæˆ‘ä¸çŸ¥é“ã€‚<br>
            å»äº†å†è¯´å§ã€‚ä½†ä»–ä»¬ä»€ä¹ˆéƒ½ä¸è¯´ï¼Œè¦æ€ä¹ˆæ‰èƒ½æ‹¿åˆ°ç‹ç‹¸å²›çš„é€šå…³ç›–ç« å‘¢ï¼Ÿ<br>
            â€œä¸‹èˆ¹å•¦ï¼Œä¸‹èˆ¹å•¦ã€‚â€<br>
            â€œè¦æ‹¿åˆ°é€šå…³ç›–ç« ï¼Œå¾—é ä½ ä»¬è‡ªå·±ã€‚14å¤©åï¼Œè¿˜æ˜¯åœ¨è¿™é‡Œï¼Œæ‹¿åˆ°ç›–ç« è€…ï¼Œå³å°†å‰å¾€ä¸‹ä¸€å²›ã€‚<br>
            å¤±è´¥è€…ï¼Œé£è¿”å›æ‘ã€‚â€œ<br>
            â€œå»å§ã€‚â€
        </div>
    </div>
    <div class="lobby-content">
        <div class="lobby-title-main">é’“é±¼ç‰Œ</div>
        <div class="lobby-title-sub">æ— å°½å¡”æ¥¼</div>
        <div class="lobby-orientation">&lt; æ¨ªå±æ¸¸ç© &gt;</div>
        <button class="btn btn-lobby" onclick="game.enterMapMode()">å¼€å§‹æŒ‘æˆ˜</button>
    </div>
    <div style="position: absolute; bottom: 20px; right: 20px; color: rgba(255,255,255,0.3); font-family: monospace;">v3.2.2</div>
</div>

<header>
    <div class="header-left lobby-hide" id="header-left-col">
        <div class="level-id" id="level-id">FLOOR 1-1</div>
        <div class="level-goal"><span>å…³å¡ç›®æ ‡ï¼š</span><span id="level-desc" style="color:#ddd">åŠ è½½ä¸­...</span></div>
    </div>
    <div class="header-center">
        <!-- Info Btn (Poker Card) -->
        <div class="icon-btn" onclick="game.toggleInfo()" title="ç‰Œå‹è¯´æ˜">
            <svg viewBox="0 0 24 24"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14h-2v-4h2v4zm0-6h-2V7h2v4z"/></svg>
        </div>
        <!-- Audio Btn -->
        <div class="icon-btn" id="audio-toggle" onclick="game.toggleAudio()" title="åˆ‡æ¢æ°›å›´éŸ³æ•ˆ">
            <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
        </div>
        <!-- Fullscreen Btn -->
        <div class="icon-btn" id="fs-toggle" onclick="game.toggleFullscreen()" title="å…¨å±åˆ‡æ¢">
            <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
        </div>
    </div>
    <div class="header-right lobby-hide" id="header-right-col">
        <div class="passive-dock" id="passive-list"></div>
        <div class="gold-container">
            <span class="bet-info" id="bet-display">ä¸‹æ³¨: 0</span>
            <div class="gold-pill">ğŸ’° <span id="gold-display">0</span></div>
        </div>
    </div>
</header>

<div id="main-stage">
    <div class="panel" id="left-panel">
        <div class="panel-title" id="opp-name">å¯¹æ‰‹</div>
        <div class="avatar" id="opp-avatar"></div>
        <div class="opp-speech" id="opp-speech"></div>
        <div style="font-size:12px; color:#aaa; margin-bottom:5px;">æ‰‹ç‰Œ: <span id="opp-count">7</span></div>
        <div class="opp-hand-grid" id="opp-hand-container"></div>
    </div>
    <div class="panel" id="center-panel">
        <div class="panel-title">å…¬å…±ç‰Œæ¡Œ</div>
        <div class="baits-container">
            <div class="bait-row"><div class="bait-label">Ta çš„<br>è¯±é¥µ</div><div id="opp-bait-container" style="display:flex; gap:10px"></div></div>
            <div style="height:20px;"></div>
            <div class="bait-row"><div class="bait-label">æˆ‘çš„<br>è¯±é¥µ</div><div id="my-bait-container" style="display:flex; gap:10px"></div></div>
        </div>
        <div id="player-hand-area"><div id="hand-container"></div></div>
    </div>
    <div class="panel" id="right-panel">
        <div class="panel-title">æ§åˆ¶å°</div>
        <div class="action-area">
            <div id="phase-tip" style="text-align:center; color:#888; font-size:12px; margin-bottom:10px;">å‡†å¤‡ä¸­...</div>
            <button id="btn-bait" class="btn btn-primary" style="display:none">æ”¾å…¥è¯±é¥µ (0/2)</button>
            <div id="play-group" style="display:none; flex-direction:column; gap:10px;">
                <button id="btn-combo-opp" class="btn" disabled><span>å’Œ TA è¯±é¥µç»„åˆ</span></button>
                <button id="btn-combo-mine" class="btn" disabled><span>å’Œ æˆ‘çš„ è¯±é¥µç»„åˆ</span></button>
                <div style="text-align:center;font-size:10px;">OR</div>
                <button id="btn-play-hand" class="btn" disabled><span>ç›´æ¥å‡º 5 å¼ æ‰‹ç‰Œ</span></button>
            </div>
            <div id="skill-confirm-group" style="display:none; flex-direction:column; gap:5px;">
                <div id="skill-desc-text" style="font-size:11px; color:var(--rare); text-align:center; margin-bottom:5px;"></div>
                <button id="btn-skill-ok" class="btn btn-primary" style="background:var(--rare)">ç¡®è®¤æ–½æ³•</button>
                <button id="btn-skill-no" class="btn">å–æ¶ˆ</button>
            </div>
            <div id="bet-panel" style="display:none; flex-direction:column; gap:8px;">
                <div style="text-align:center; color:gold;">å¹»æ³¨: é€‰æ‹©ä¸‹æ³¨é¢</div>
                <button class="btn" id="bet-btn-1" onclick="game.placeBet(0)">ä¸‹æ³¨ 30%</button>
                <button class="btn" id="bet-btn-2" onclick="game.placeBet(1)">ä¸‹æ³¨ 50%</button>
                <button class="btn" onclick="game.cancelSkill()">å–æ¶ˆ</button>
            </div>
        </div>
        <div style="width:100%; border-top:1px solid #444; padding-top:10px; margin-top:20px;">
            <div class="panel-title" style="border:none; margin:0;">æŠ€èƒ½</div>
            <div id="skill-dock"></div>
        </div>
    </div>
</div>

<div id="overlay-screen" class="overlay"></div>
<div id="global-tooltip"></div>

<!-- Fullscreen Shop & Inventory UI -->
<div id="shop-screen">
    <!-- Left: Equipment -->
    <div id="shop-inv-left">
        <div style="text-align: center; padding: 15px; font-weight: bold; color: var(--gold-color); font-size: 18px; border-bottom: 1px solid rgba(255,255,255,0.1); flex-shrink: 0; z-index: 2; position: relative; background: inherit;">
            å·²ä½©æˆ´é“å…·
            <div style="font-size: 10px; color:#aaa; font-weight:normal; margin-top:5px;">å†…åœˆ: æŠ€èƒ½ | å¤–åœˆ: æ™®é€šé“å…·</div>
        </div>
        <div id="equip-circle-container" style="flex: 1; position: relative; overflow: hidden; display: flex; align-items: center; justify-content: center;">
            <!-- Circular slots will be generated via JS -->
        </div>
    </div>
    <!-- Right: Tabs & Content -->
    <div id="shop-inv-right">
        <div style="display: flex; border-bottom: 1px solid rgba(255,255,255,0.1); flex-shrink: 0;">
            <div id="tab-btn-shop" class="shop-tab active" onclick="game.switchShopTab('shop')">å•†åŸ</div>
            <div id="tab-btn-inventory" class="shop-tab" onclick="game.switchShopTab('inventory')">èƒŒåŒ…</div>
            <div style="margin-left: auto; padding: 15px; color: var(--gold-color); font-weight: bold;">ğŸ’° <span id="shop-modal-gold">0</span></div>
        </div>
        <div id="tab-content-shop" style="flex: 1; overflow-y: auto; padding: 15px;">
            <!-- Dynamic Shop Layout -->
        </div>
        <div id="tab-content-inventory" style="flex: 1; overflow-y: auto; padding: 20px; display: none;">
            <!-- Grid of inventory items -->
        </div>
        <div style="padding: 15px; border-top: 1px solid rgba(255,255,255,0.1); text-align: center; flex-shrink: 0; background: rgba(0,0,0,0.3);">
            <button class="btn btn-primary" style="width: 200px;" onclick="game.leaveShop()">è¿›å…¥ä¸‹ä¸€å…³å¡</button>
        </div>
    </div>
</div>

<!-- Floating tooltip for item interaction -->
<div id="item-interact-bubble" style="display: none; position: absolute; background: rgba(0,0,0,0.95); border: 1px solid var(--gold-color); border-radius: 8px; padding: 15px; z-index: 1000; width: 220px; box-shadow: 0 5px 25px rgba(0,0,0,0.9);">
    <div id="interact-name" style="color: var(--highlight); font-weight: bold; margin-bottom: 5px; font-size: 14px;"></div>
    <div id="interact-desc" style="color: #ccc; font-size: 12px; margin-bottom: 15px; line-height: 1.4;"></div>
    <button id="interact-btn" class="btn btn-primary" style="width: 100%;">è£…å¤‡</button>
</div>

<div id="info-screen" class="overlay" onclick="game.toggleInfo()">
    <div class="info-panel" onclick="event.stopPropagation()">
        <h3 style="color:var(--highlight); margin-bottom:15px; text-align:center;">ç‰Œå‹è¯´æ˜</h3>
        <div id="info-content"></div>
        <div class="info-footer">
            ç‰Œå‹ã€èŠ±è‰²ã€ç‚¹æ•°å¤§å°è¯´æ˜ï¼š<br>
            åŒèŠ±é¡º > å››ç‚¸ > è‘«èŠ¦ > åŒèŠ± > é¡ºå­ > ä¸‰æ¡ > ä¸¤å¯¹ > å•ç‰Œ<br>
            èŠ±è‰²å¤§å°ï¼šé»‘æ¡ƒ > çº¢å¿ƒ > æ–¹å— > æ¢…èŠ±<br>
            ç‚¹æ•°å¤§å°ï¼šA > K > Q > J > 10 > 9 > 8 > 7 > 6 > 5 > 4 > 3 > 2
            <br><span style="color:var(--gold-color)">æ¯å±€è·å¾—é‡‘å¸ï¼šä¸ºæœ¬å±€ç‰Œå‹å¯¹åº”ç§¯åˆ†çš„ 10%</span>
        </div>
    </div>
</div>

<!-- Tutorial Fullscreen Page -->
<div id="tutorial-screen">
    <div class="envelope-container">
        <div class="letter-modal">
            <div class="letter-stamp">ç‹</div>
            <div class="letter-header">æ–°æ‰‹å¼•å¯¼ï¼</div>
            <div class="letter-body">
                å†’é™©è€…ï¼š<br>
                æ¬¢è¿æ¥åˆ°ç‹ç‹¸å²›ï¼Œè¿™é‡Œå……æ»¡äº†æœºé‡ï¼Œä¹Ÿå¤„å¤„æ˜¯å±é™©ï¼Œä¸è¦å¤ªç›¸ä¿¡çœ¼å‰çš„äº‹ç‰©ã€‚æƒ³è¦æ‹¿åˆ°å¾½ç« ï¼Ÿæ— å°½å¡”æ¥¼å°±åœ¨å‰æ–¹ï¼Œä½ å»ä¾¿æ˜¯ï¼ä½†è¦æ³¨æ„ï¼Œç•™å¿ƒè§‚å¯Ÿæ¯ä¸€å±‚æŒ‘æˆ˜ç›®æ ‡ï¼Œåˆ«å¤§æ„ï¼<br>
                <b class="hl-txt">ã€å…³å¡ç›®æ ‡ã€‘</b>æ˜¯é€šå…³çš„é‡ç‚¹ï¼Œåœ¨é¡¶éƒ¨æ å·¦ä¾§å¯ä»¥æŸ¥çœ‹ã€‚<br>
                <b class="hl-txt">ã€æ¸¸æˆè§„åˆ™ã€‘</b>æ¯äºº 7 å¼ æ‰‹ç‰Œï¼Œæ”¾ 2 å¼ è¯±é¥µç‰Œï¼Œæ¥ç€æ‰‹ä¸­çš„ 5 å¼ æ‰‹ç‰Œå¯ä»¥æ‹¿å‡º 3 å¼ ä¸åŒæ–¹æ”¾ç½®çš„ 2 å¼ è¯±é¥µç‰Œè¿›è¡Œç»„åˆæˆæœ€ç»ˆçš„ 5 å¼ ç‰Œï¼Œä¹Ÿå¯ä»¥ç›´æ¥å‡ºæ‰‹ä¸­çš„ 5 å¼ ç‰Œï¼›<br>
                <b class="hl-txt">ã€å¯¹å±€è¯´æ˜ã€‘</b>ç‰Œå‹åˆ†ä¸ºåŒèŠ±é¡º>å››ç‚¸>è‘«èŠ¦>åŒèŠ±>é¡ºå­>ä¸‰æ¡>ä¸¤å¯¹>å•ç‰Œ ï¼›ä¸åŒç‰Œå‹è·å¾—çš„ç§¯åˆ†ä¹Ÿä¸åŒï¼Œå¯ä»¥åœ¨ç‰Œå‹è¯´æ˜ä¸­çœ‹åˆ°ï¼›<br>
                <b class="hl-txt">ã€æ¸¸ç©æŠ€å·§ã€‘</b>å…³å¡ä¸­æ”¯æŒä½¿ç”¨é“å…·æŠ€èƒ½ï¼Œå¸®åŠ©ä½ é¡ºåˆ©é€šå…³ï¼<br>
                ç¥ä½ å¥½è¿ï¼è‹¥èƒ½é¡ºåˆ©ç™»ä¸Šæ— å°½å¡”æ¥¼8 å±‚ï¼Œä½ ä¼šå†çœ‹åˆ°æˆ‘çš„ï¼Œã€ç‹ç‹¸å¾½ç« ã€‘å°±åœ¨é‚£ï¼
            </div>
            <div class="letter-footer">
                <button class="btn btn-primary" style="width:200px; padding:15px; font-size: 16px;" onclick="game.closeTutorial()">æ”¶ä¸‹ä¿¡ä»¶</button>
            </div>
        </div>
    </div>
</div>

<script>
// =================== éŸ³é¢‘å¼•æ“ (Web Audio API) ===================
class AtmosphereAudio {
    constructor() { this.ctx = null; this.masterGain = null; this.bgmGain = null; this.sfxGain = null; this.isPlaying = false; this.oceanNode = null; this.synthInterval = null; this.notes =[138.59, 164.81, 185.00, 207.65, 246.94]; }
    init() { if (!this.ctx) { const AudioContext = window.AudioContext || window.webkitAudioContext; this.ctx = new AudioContext(); this.masterGain = this.ctx.createGain(); this.masterGain.gain.value = 0.5; this.masterGain.connect(this.ctx.destination); this.bgmGain = this.ctx.createGain(); this.bgmGain.gain.value = 1.0; this.bgmGain.connect(this.masterGain); this.sfxGain = this.ctx.createGain(); this.sfxGain.gain.value = 1.0; this.sfxGain.connect(this.masterGain); } }
    createPinkNoise() { const bufferSize = 2 * this.ctx.sampleRate; const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate); const output = buffer.getChannelData(0); let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0; for (let i = 0; i < bufferSize; i++) { const white = Math.random() * 2 - 1; b0 = 0.99886 * b0 + white * 0.0555179; b1 = 0.99332 * b1 + white * 0.0750759; b2 = 0.96900 * b2 + white * 0.1538520; b3 = 0.86650 * b3 + white * 0.3104856; b4 = 0.55000 * b4 + white * 0.5329522; b5 = -0.7616 * b5 - white * 0.0168980; output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362; output[i] *= 0.11; b6 = white * 0.115926; } const noise = this.ctx.createBufferSource(); noise.buffer = buffer; noise.loop = true; return noise; }
    startOcean() { const noise = this.createPinkNoise(); const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 400; const lfo = this.ctx.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 0.15; const lfoGain = this.ctx.createGain(); lfoGain.gain.value = 300; lfo.connect(lfoGain); lfoGain.connect(filter.frequency); noise.connect(filter); filter.connect(this.bgmGain); noise.start(); lfo.start(); this.oceanNode = { noise, lfo }; }
    playNote() { if(!this.isPlaying) return; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); const note = this.notes[Math.floor(Math.random() * this.notes.length)]; const freq = Math.random() > 0.7 ? note * 2 : note; osc.frequency.value = freq; osc.type = 'sine'; gain.gain.setValueAtTime(0, this.ctx.currentTime); gain.gain.linearRampToValueAtTime(0.15, this.ctx.currentTime + 2); gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8); osc.connect(gain); gain.connect(this.bgmGain); osc.start(); osc.stop(this.ctx.currentTime + 8); }
    duckBgm(duration) { if (!this.bgmGain) return; const t = this.ctx.currentTime; this.bgmGain.gain.cancelScheduledValues(t); this.bgmGain.gain.setValueAtTime(this.bgmGain.gain.value, t); this.bgmGain.gain.linearRampToValueAtTime(0.2, t + 0.1); this.bgmGain.gain.linearRampToValueAtTime(1.0, t + duration); }
    playCardSlide() { if(!this.isPlaying) return; const t = this.ctx.currentTime; const noise = this.createPinkNoise(); const noiseGain = this.ctx.createGain(); const filter = this.ctx.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.setValueAtTime(800, t); filter.frequency.linearRampToValueAtTime(1200, t + 0.1); noiseGain.gain.setValueAtTime(0.4, t); noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15); noise.connect(filter); filter.connect(noiseGain); noiseGain.connect(this.sfxGain); noise.start(t); noise.stop(t + 0.15); }
    playTick() { if(!this.isPlaying) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'triangle'; osc.frequency.setValueAtTime(400, t); gain.gain.setValueAtTime(1.5, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05); osc.connect(gain); gain.connect(this.sfxGain); osc.start(t); osc.stop(t + 0.05); }
    playCoin() { if(!this.isPlaying) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'sine'; osc.frequency.setValueAtTime(1500 + Math.random() * 500, t); gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1); osc.connect(gain); gain.connect(this.sfxGain); osc.start(t); osc.stop(t + 0.1); }
    playWin() { if(!this.isPlaying) return; this.duckBgm(2.5); const t = this.ctx.currentTime; const freqs =[523.25, 659.25, 783.99]; freqs.forEach((f, i) => { const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'sine'; osc.frequency.value = f; gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.4, t + 0.1 + (i*0.05)); gain.gain.exponentialRampToValueAtTime(0.001, t + 2.0); osc.connect(gain); gain.connect(this.sfxGain); osc.start(t); osc.stop(t + 2.0); }); }
    playLose() { if(!this.isPlaying) return; this.duckBgm(1.5); const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'triangle'; osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(80, t + 1.5); gain.gain.setValueAtTime(0.4, t); gain.gain.linearRampToValueAtTime(0, t + 1.5); osc.connect(gain); gain.connect(this.sfxGain); osc.start(t); osc.stop(t + 1.5); }
    toggle() { this.init(); if (this.ctx.state === 'suspended') this.ctx.resume(); if (this.isPlaying) { this.stop(); } else { this.start(); } return this.isPlaying; }
    start() { if(this.isPlaying) return; this.isPlaying = true; this.startOcean(); this.playNote(); this.synthInterval = setInterval(() => { if(Math.random() > 0.4) this.playNote(); }, 4000); }
    stop() { this.isPlaying = false; if(this.oceanNode) { this.oceanNode.noise.stop(); this.oceanNode.lfo.stop(); this.oceanNode = null; } if(this.synthInterval) clearInterval(this.synthInterval); }
}

// =================== é…ç½®åŒº ===================
const LEVEL_CONFIG =[];
for (let floor = 1; floor <= 8; floor++) {
    // Step 1: Best of 3 (x-1)
    LEVEL_CONFIG.push({
        id: `${floor}-1`,
        floor: floor,
        step: 1,
        target: 'best_of_3',
        gold: 0,
        rounds: 3,
        openHand: false,
        name: 'æš—ç‰Œ-3å±€2èƒœ',
        desc: '3å±€2èƒœï¼Œå›åˆç‰Œå‹èµ¢è¿‡å¯¹æ–¹å³èƒœ',
    });

    // Step 2: Boss Accumulate (x-2)
    let bossGold = 400 * floor;
    if (floor === 4) bossGold = 4000;
    if (floor === 5) bossGold = 9000;
    if (floor === 6) bossGold = 22000;
    if (floor === 7) bossGold = 55000;
    if (floor === 8) bossGold = 150000;

    LEVEL_CONFIG.push({
        id: `${floor}-2`, 
        floor: floor,
        step: 2,
        target: 'accumulate',
        gold: bossGold,
        rounds: 3,
        openHand: false, 
        name: 'æš—ç‰Œ-ç§¯åˆ†æŒ‘æˆ˜',
        desc: `3 å›åˆå†…ç§¯åˆ† â‰¥ x/${bossGold}`,
        boss: true
    });
}

const OPPONENT_PERSONAS = {
    1:[ {name:"é›¾éšå®¢", text:"é›¾é”ç‰Œè·¯ï¼Œä½ è¿è‡ªå·±éƒ½çœ‹ä¸æ¸…ã€‚"}, {name:"å½±å¼ˆè€…", text:"ä½ çš„æ‰‹ï¼Œæ—©è¢«æˆ‘çš„å½±å­æ¡ä½äº†ã€‚"}, {name:"æ— ç›¸å¸å‘½", text:"å‘½æ— å®šå½¢ï¼Œæ±äº¦æ— èƒœæœºã€‚"} ],
    2:[ {name:"è§æƒ‘ä½¿", text:"ç«æ˜Ÿç…§å‘½ï¼Œæ­¤å±€è¡€å…‰å·²ç°ã€‚"}, {name:"å²ç ´å¾’", text:"ç ´ä½ å¸ƒå±€ï¼Œå¦‚æŠ˜æ¯æã€‚"}, {name:"åŒ—æ–—åˆ‘å®˜", text:"ä¸ƒæ˜Ÿè½å­ï¼Œç½ªç½šå·²å®šã€‚"} ],
    3:[ {name:"æ¢¦ç¼šå¸ˆ", text:"æ²‰æººæ—§æ¢¦è€…ï¼Œä¸é…é†’ç€èµ¢ã€‚"}, {name:"çµçŠ€ç›—", text:"ä½ çš„å¿ƒæ„ï¼Œæˆ‘å·²å·æ¥çœ‹é€ã€‚"}, {name:"å¿˜å·å®ˆç—´", text:"æ‰§å¿µå¤ªé‡ï¼Ÿé‚£å°±æ°¸ç•™æ­¤å²¸ã€‚"} ],
    4:[ {name:"ç„°éª°å®¢", text:"èµŒå¾—è¶Šå¤§ï¼Œçƒ§å¾—è¶Šå¹²å‡€ã€‚"}, {name:"é‡‘ç³å¾’", text:"é‡‘å¸é—ªå…‰æ—¶ï¼Œä¾¿æ˜¯ä½ å¤±æ˜ä¹‹åˆ»ã€‚"}, {name:"é¥•å¼ˆå°Š", text:"è´ªå¿ƒä¸è¶³ï¼Ÿæ­£å¥½å–‚æˆ‘æ£‹è…¹ã€‚"} ],
    5:[ {name:"è™šè¨€ä½¿", text:"æˆ‘è¯´çœŸè¯ï¼Œä½†ä½ ä¿¡å—ï¼Ÿ"}, {name:"å›å£°å®¢", text:"ä½ ä¸Šä¸€æ­¥ï¼Œå·²æ˜¯æˆ‘çš„ä¼ç¬”ã€‚"}, {name:"åƒé¢ç‹å›", text:"çŒœçŒœè¿™å‰¯é¢å…·ä¸‹ï¼Œæ˜¯ç¬‘è¿˜æ˜¯æ€ï¼Ÿ"} ],
    6:[ {name:"å¹»æ½®å¸ˆ", text:"ç‰Œå¦‚æ½®æ¶Œï¼Œç†æ™ºå°†æ²‰ã€‚"}, {name:"å¦„å¿µå¾’", text:"ä½ ä»¥ä¸ºçš„èƒœç®—ï¼Œåªæ˜¯å¹»è§‰ã€‚"}, {name:"å¤§å¦„å¤©ç‹", text:"å¤©åœ°çš†å¦„ï¼Œå”¯æˆ‘å¼ˆçœŸã€‚"} ],
    7:[ {name:"å¯‚é»˜å®¢", text:"æ²‰é»˜ï¼Œæ˜¯ä½ æœ€åçš„å£°éŸ³ã€‚"}, {name:"ç©ºç—•ä½¿", text:"ç—•è¿¹ä¸ç•™ï¼Œèƒœè´¥æˆç©ºã€‚"}, {name:"å½’å¯‚ç™½ç‹", text:"æ”¾ä¸‹èƒœè´Ÿï¼Œæˆ–æ°¸é™·è™šæ— ã€‚"} ],
    8:[ {name:"å¿ƒé•œå¸ˆ", text:"ç…§è§ä½ å¿ƒåº•çš„ç ´ç»½äº†ã€‚"}, {name:"å°¾è¿¹å®¢", text:"ä¹å°¾ç•™ç—•ï¼Œæ­¥æ­¥çš†æˆ‘é¢„è®¾ã€‚"}, {name:"ä¹å°¾å¼ˆå¿ƒå›", text:"å…«é‡è¯•ç‚¼å°½ï¼Œå¯æ•¢ä¸æˆ‘å¼ˆå¿ƒï¼Ÿ"} ]
};

const SKILLS_DB = {
    xuanji: { name: 'ç„æœº', icon: 'ğŸŒ€', desc: 'é€‰æ‹© 1ï½5 å¼ ç‰Œå¼ƒæ‰é‡æŠ½', type: 'round_limit', maxUses: 3 },
    yundu: { name: 'äº‘æ¸¡', icon: 'â˜ï¸', desc: 'é€‰æ‹© 1 å¼ ç‰Œä¸å¯¹æ–¹æ‰‹ç‰Œéšæœºäº¤æ¢', type: 'consumable' },
    huanzhu: { name: 'å¹»æ³¨', icon: 'ğŸ’¸', desc: 'é€‰æ‹©æ¯”ä¾‹ä¸‹æ³¨ï¼ˆä»…-2å…³å¡å¯ç”¨ï¼‰', type: 'once_per_round' },
    xinjing: { name: 'å¿ƒé•œ', icon: 'ğŸ”®', desc: 'æå‰æŸ¥çœ‹å¯¹æ–¹è¯±é¥µç‰Œ', type: 'consumable' },
    abyss: { name: 'æ·±æ¸Šä¹‹çœ¼', icon: 'ğŸ‘ï¸', desc: 'æŸ¥çœ‹å¯¹æ–¹æ‰‹ç‰Œ', type: 'consumable' },
    mirror: { name: 'é•œç•Œ', icon: 'ğŸª', desc: 'å¤åˆ¶å¯¹æ–¹æ‰‹ç‰Œ', type: 'consumable' },
    blast: { name: 'çˆ†ç ´', icon: 'ğŸ’¥', desc: 'é€‰æ‹© 1 å¼ ç‰Œä¸å¯¹æ–¹æŒ‡å®šç‰Œäº¤æ¢', type: 'consumable' }
};

const REWARD_POOL =[
    { id: 'guchen', weight: 60, name: 'å­¤è¾°', desc: 'ç»“ç®—æ—¶ç‰Œå‹ä¸ºå•ç‰Œï¼Œè·å¾—é“å…·åŠ å€ç§¯åˆ†ï¼Œç‰Œå‹ç§¯åˆ†x2', type: 'passive', icon: 'ğŸƒ', trigger:'å•ç‰Œ', mult:1, price: 30, unique: true },
    { id: 'shuangying', weight: 60, name: 'åŒå½±', desc: 'ç»“ç®—æ—¶ç‰Œå‹ä¸ºå¯¹å­ï¼Œè·å¾—é“å…·åŠ å€ç§¯åˆ†ï¼Œç‰Œå‹ç§¯åˆ†x2', type: 'passive', icon: 'â™Š', trigger:'å¯¹å­', mult:1, price: 30, unique: true },
    { id: 'sixiang', weight: 60, name: 'å››è±¡', desc: 'ç»“ç®—æ—¶ç‰Œå‹ä¸ºä¸¤å¯¹ï¼Œè·å¾—é“å…·åŠ å€ç§¯åˆ†ï¼Œç‰Œå‹ç§¯åˆ†x2', type: 'passive', icon: 'ğŸ˜', trigger:'ä¸¤å¯¹', mult:1, price: 30, unique: true },
    { id: 'sanyuan', weight: 60, name: 'ä¸‰å£', desc: 'ç»“ç®—æ—¶ç‰Œå‹ä¸ºä¸‰æ¡ï¼Œè·å¾—é“å…·åŠ å€ç§¯åˆ†ï¼Œç‰Œå‹ç§¯åˆ†x3', type: 'passive', icon: 'â­', trigger:'ä¸‰æ¡', mult:2, price: 30, unique: true },
    { id: 'lianchao', weight: 60, name: 'è¿æ½®', desc: 'ç»“ç®—æ—¶ç‰Œå‹ä¸ºé¡ºå­ï¼Œè·å¾—é“å…·åŠ å€ç§¯åˆ†ï¼Œç‰Œå‹ç§¯åˆ†x3', type: 'passive', icon: 'ğŸŒŠ', trigger:'é¡ºå­', mult:2, price: 30, unique: true },
    { id: 'yise', weight: 60, name: 'ä¸€è‰²', desc: 'ç»“ç®—æ—¶ç‰Œå‹ä¸ºåŒèŠ±ï¼Œè·å¾—é“å…·åŠ å€ç§¯åˆ†ï¼Œç‰Œå‹ç§¯åˆ†x3', type: 'passive', icon: 'ğŸ¨', trigger:'åŒèŠ±', mult:2, price: 30, unique: true },
    { id: 'fulu', weight: 60, name: 'ç¦ç¦„', desc: 'ç»“ç®—æ—¶ç‰Œå‹ä¸ºè‘«èŠ¦ï¼Œè·å¾—é“å…·åŠ å€ç§¯åˆ†ï¼Œç‰Œå‹ç§¯åˆ†x4', type: 'passive', icon: 'ğŸº', trigger:'è‘«èŠ¦', mult:3, price: 30, unique: true },
    { id: 'siji', weight: 60, name: 'å››æ', desc: 'ç»“ç®—æ—¶ç‰Œå‹ä¸ºå››ç‚¸ï¼Œè·å¾—é“å…·åŠ å€ç§¯åˆ†ï¼Œç‰Œå‹ç§¯åˆ†x4', type: 'passive', icon: 'âš¡', trigger:'å››ç‚¸', mult:3, price: 30, unique: true },
    { id: 'tianlv', weight: 60, name: 'å¤©å¾‹', desc: 'ç»“ç®—æ—¶ç‰Œå‹ä¸ºåŒèŠ±é¡ºï¼Œè·å¾—é“å…·åŠ å€ç§¯åˆ†ï¼Œç‰Œå‹ç§¯åˆ†x5', type: 'passive', icon: 'ğŸ“œ', trigger:'åŒèŠ±é¡º', mult:4, price: 30, unique: true },
    
    // Skill items available in shop
    { id: 'yundu', weight: 20, name: 'äº‘æ¸¡', desc: 'é€‰æ‹© 1 å¼ ç‰Œä¸å¯¹æ–¹æ‰‹ç‰Œéšæœºäº¤æ¢', type: 'item_active', ref: 'yundu', unique: false, icon: 'â˜ï¸', price: 200 },
    { id: 'huanzhu', weight: 20, name: 'å¹»æ³¨', desc: 'é€‰æ‹©æ¯”ä¾‹ä¸‹æ³¨ï¼ˆä»…-2å…³å¡å¯ç”¨ï¼‰', type: 'item_active', ref: 'huanzhu', unique: true, icon: 'ğŸ’¸', price: 200 },
    { id: 'xinjing', weight: 20, name: 'å¿ƒé•œ', desc: 'æå‰æŸ¥çœ‹å¯¹æ–¹è¯±é¥µç‰Œ', type: 'item_active', ref: 'xinjing', unique: false, icon: 'ğŸ”®', price: 50 },
    { id: 'abyss', weight: 20, name: 'æ·±æ¸Šä¹‹çœ¼', desc: 'æŸ¥çœ‹å¯¹æ–¹æ‰‹ç‰Œ', type: 'item_active', ref: 'abyss', unique: false, icon: 'ğŸ‘ï¸', price: 50 },
    { id: 'mirror', weight: 20, name: 'é•œç•Œ', desc: 'å¤åˆ¶å¯¹æ–¹æ‰‹ç‰Œ', type: 'item_active', ref: 'mirror', unique: false, icon: 'ğŸª', price: 50 },
    { id: 'blast', weight: 20, name: 'çˆ†ç ´', desc: 'é€‰æ‹© 1 å¼ ç‰Œä¸å¯¹æ–¹æŒ‡å®šç‰Œäº¤æ¢', type: 'item_active', ref: 'blast', unique: false, icon: 'ğŸ’¥', price: 50 },
    
    // Upgrades
    { id: 'xuanshu', weight: 10, name: 'ç„æ¢', desc: 'ã€ç„æœºã€‘ä½¿ç”¨æ¬¡æ•°+1', type: 'upgrade', icon: 'ğŸ†™', effect: 'add_xuanji', getPrice: (game) => game.upgradeCounts.xuanshu ? 100 : 50 },
    { id: 'huance', weight: 10, name: 'å¹»ç­–', desc: 'ã€å¹»æ³¨ã€‘ä¸‹æ³¨æ¯”ä¾‹+10%', type: 'upgrade', icon: 'ğŸ’¹', effect: 'boost_bet', getPrice: (game) => game.upgradeCounts.huance ? 100 : 50 },
    { id: 'xinyu', weight: 5, name: 'å¿ƒå±¿', desc: 'æŠ€èƒ½æ§½ä½æ•°+1', type: 'upgrade', icon: 'ğŸ§©', effect: 'add_slot', getPrice: (game) => game.upgradeCounts.xinyu ? 100 : 50 },
    
    // Dynamic Passives
    { id: 'yangyao', weight: 20, name: 'é˜³çˆ»', desc: 'ç»“ç®—æ—¶ç‰Œå‹åŒ…å«å¥‡æ•° ï¼ˆ1ã€3ã€5ã€7ã€9ï¼‰ï¼Œè·å¾—ç‰Œå‹ç§¯åˆ† xæ¯1å¼ ç‰Œæ•°', type: 'passive', icon: 'ğŸ”†', trigger: 'odd', unique: true, price: 100 },
    { id: 'yinyao', weight: 20, name: 'é˜´çˆ»', desc: 'ç»“ç®—æ—¶ç‰Œå‹åŒ…å«å¶æ•°ï¼ˆ2ã€4ã€6ã€8ã€10ï¼‰ï¼Œè·å¾—ç‰Œå‹ç§¯åˆ† xæ¯1å¼ ç‰Œæ•°', type: 'passive', icon: 'ğŸŒ‘', trigger: 'even', unique: true, price: 100 },
    { id: 'qishi', weight: 20, name: 'éª‘å£«', desc: 'ç»“ç®—æ—¶ç‰Œå‹åŒ…å«äººå¤´ç‰Œï¼ˆJã€Qã€K)ï¼Œæ¯ 1 å¼ å¯è·å¾—ç‰Œå‹ç§¯åˆ† x10', type: 'passive', icon: 'ğŸ›¡ï¸', trigger: 'face', unique: true, price: 50 },
    { id: 'fishhook', weight: 20, name: 'é»„é‡‘é±¼é’©', desc: 'é’“é±¼æˆåŠŸï¼Œå€æ•°+1', type: 'passive', icon: 'ğŸª', trigger: 'fishhook', unique: true, price: 50 }
];

const HAND_TYPES_BASE =[
    { name: 'åŒèŠ±é¡º', en:'Straight Flush', base: 300, level:9 }, { name: 'å››ç‚¸', en:'Four of a Kind', base: 200, level:8 }, 
    { name: 'è‘«èŠ¦', en:'Full House', base: 160, level:7 }, { name: 'åŒèŠ±', en:'Flush', base: 120, level:6 }, 
    { name: 'é¡ºå­', en:'Straight', base: 90, level:5 }, { name: 'ä¸‰æ¡', en:'Three of a Kind', base: 60, level:4 }, 
    { name: 'ä¸¤å¯¹', en:'Two Pair', base: 40, level:3 }, { name: 'å¯¹å­', en:'Pair', base: 20, level:2 }, 
    { name: 'å•ç‰Œ', en:'High Card', base: 10, level:1 }
];
const SUITS =['â™ ', 'â™¥', 'â™£', 'â™¦'];
const RANKS =['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
const RANK_VALUES = { '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, '10':10, 'J':11, 'Q':12, 'K':13, 'A':14 };
const SUIT_VALS = { 'â™ ':4, 'â™¥':3, 'â™¦':2, 'â™£':1 };

const PokerEngine = {
    evaluate: (cards) => {
        if (!cards || cards.length < 5) return { score: 0, name: 'ä¸è¶³', payout: 0, cards:[] };
        let sorted = [...cards].sort((a,b) => b.value - a.value);
        const v = sorted.map(c => c.value); const s = sorted.map(c => c.suit);
        const isFlush = s.every(x => x === s[0]); let isStraight = true;
        for(let i=0; i<4; i++) { if(v[i] - v[i+1] !== 1) isStraight = false; }
        if(!isStraight && v[0]===14 && v[1]===5 && v[2]===4 && v[3]===3 && v[4]===2) isStraight = true;
        const counts = {}; v.forEach(x => counts[x] = (counts[x] || 0) + 1);
        const arr = Object.values(counts).sort((a,b) => b - a);
        let t = HAND_TYPES_BASE[8];
        if(isFlush && isStraight) t = HAND_TYPES_BASE[0]; else if(arr[0]===4) t = HAND_TYPES_BASE[1]; else if(arr[0]===3 && arr[1]===2) t = HAND_TYPES_BASE[2]; else if(isFlush) t = HAND_TYPES_BASE[3]; else if(isStraight) t = HAND_TYPES_BASE[4]; else if(arr[0]===3) t = HAND_TYPES_BASE[5]; else if(arr[0]===2 && arr[1]===2) t = HAND_TYPES_BASE[6]; else if(arr[0]===2) t = HAND_TYPES_BASE[7];
        sorted.sort((a, b) => { const ca = counts[a.value], cb = counts[b.value]; if(ca !== cb) return cb - ca; if(a.value !== b.value) return b.value - a.value; return SUIT_VALS[b.suit] - SUIT_VALS[a.suit]; });
        let raw = t.level * 1000000000000;
        sorted.forEach((c, i) => { raw += (c.value * 10 + SUIT_VALS[c.suit]) * Math.pow(200, 4 - i); });
        return { ...t, rawScore: raw, cards: sorted };
    },
    getStrategicBait: (hand, isBoss) => {
        let sorted =[...hand].sort((a,b)=>a.value-b.value);
        let bait = [], keep =[];
        const rand = Math.random();
        if (!isBoss) {
            if (rand > 0.5) { bait =[sorted[0], sorted[1]]; keep = sorted.slice(2); } else { bait = [sorted[0], sorted[6]]; keep = sorted.slice(1,6); }
        } else {
            if (rand > 0.66) { bait = [sorted[0], sorted[1]]; keep = sorted.slice(2); } else if (rand > 0.33) { bait = [sorted[0], sorted[6]]; keep = sorted.slice(1,6); } else { bait = [sorted[2], sorted[3]]; keep = [sorted[0], sorted[1], sorted[4], sorted[5], sorted[6]]; }
        }
        return { bait, keep };
    },
    getBestCombo: (hand, bait) => {
        let bestRes = { rawScore: -1 }; const combinations =[];
        const f = (start, combo) => { if (combo.length === 3) { combinations.push(combo); return; } for (let i = start; i < hand.length; i++) { f(i + 1,[...combo, hand[i]]); } }; f(0,[]);
        combinations.forEach(comboHand => { const fullHand = [...comboHand, ...bait]; const res = PokerEngine.evaluate(fullHand); if(res.rawScore > bestRes.rawScore) bestRes = res; });
        return bestRes;
    },
    isTooStrong: (cards) => {
        const suits = {}; cards.forEach(c => suits[c.suit] = (suits[c.suit]||0) + 1); if (Object.values(suits).some(c => c >= 4)) return true; 
        const values = cards.map(c => c.value).sort((a,b)=>a-b); const counts = {}; values.forEach(v => counts[v] = (counts[v]||0) + 1); const countVals = Object.values(counts);
        if (countVals.some(c => c >= 3)) return true; 
        if (countVals.filter(c => c === 2).length >= 2) return true;
        const uniqueVals =[...new Set(values)]; if (uniqueVals.length >= 4) { for(let i=0; i <= uniqueVals.length - 4; i++) { if (uniqueVals[i+3] - uniqueVals[i] === 3) return true; } }
        return false;
    }
};

class Card { constructor(s, r) { this.suit = s; this.rank = r; this.value = RANK_VALUES[r]; this.isRed = (s==='â™¥'||s==='â™¦'); this.id = Math.random().toString(36).slice(2); this.revealed = false; } }

class Game {
    constructor() { this.tutorialShown = false; this.resetGlobal(); this.initDOM(); this.audio = new AtmosphereAudio(); this.isAudioOn = true; this.inGame = false; this.initSplash(); }
    initSplash() { const splash = document.getElementById('splash-screen'); document.addEventListener('click', () => { this.audio.init(); if(this.isAudioOn) { this.audio.start(); this.updateAudioBtn(true); } }, { once: true }); setTimeout(() => { splash.classList.add('fade-out'); setTimeout(() => { splash.style.display = 'none'; this.showLobby(); }, 1500); }, 3000); }
    resetGlobal() { 
        this.levelIndex = 0; 
        this.playerGold = 0; 
        
        this.ownedSkills =['xuanji']; 
        this.ownedPassives =[];
        this.equippedSkills = ['xuanji']; 
        this.equippedPassives =[];
        
        this.skillUsage = {}; 
        this.skillMaxModifiers = { xuanji: 0 }; 
        this.obtainedItems =[]; 
        this.upgradeCounts = { xuanshu: 0, huance: 0, xinyu: 0 }; 
        
        this.betUsedThisRound = false; 
        this.betRatios =[0.3, 0.5]; 
        this.maxSkillSlots = 3; 
        this.maxPassiveSlots = 5;
        
        this.bossDeck = null; this.drawPile =[]; this.discardPile =[]; this.opponentName = ""; this.selectedOppCard = null; this.justDealt = false; this.inGame = false; this.currentLevelWins = 0; this.currentLevelLosses = 0;
        
        this.shopDirectItems =[];
        this.availablePacks =[];
    }
    
    shuffle(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] =[array[j], array[i]]; } }

    showLobby() { this.audio.init(); if(this.isAudioOn) this.audio.start(); }
    
    enterMapMode() {
        document.getElementById('lobby-screen').style.display = 'none';
        this.showMap();
    }
    
    showMap() {
        const map = document.getElementById('map-screen');
        const scroll = document.getElementById('map-scroll-area');
        scroll.innerHTML = '';
        
        for(let f=1; f<=8; f++) {
            const group = document.createElement('div');
            group.className = 'floor-group';
            group.innerHTML = `<div class="floor-label">Floor ${f}</div>`;
            const row = document.createElement('div');
            row.className = 'nodes-row';
            const steps = LEVEL_CONFIG.filter(l => l.floor === f);
            
            steps.forEach((cfg, idx) => {
                const node = document.createElement('div');
                const levelIdx = LEVEL_CONFIG.findIndex(l => l.id === cfg.id);
                let status = 'locked';
                if (levelIdx < this.levelIndex) status = 'cleared';
                else if (levelIdx === this.levelIndex) status = 'active';
                node.className = `map-node ${status}`;
                const personas = OPPONENT_PERSONAS[f] || OPPONENT_PERSONAS[1];
                const pIndex = cfg.step === 1 ? 0 : 2;
                node.style.backgroundImage = `url('https://api.dicebear.com/7.x/bottts/svg?seed=${personas[pIndex].name}')`;
                
                if (status === 'active') {
                    node.onclick = () => { map.style.display = 'none'; this.startLevel(); };
                }
                node.innerHTML = `<div class="map-node-label">${cfg.id}</div>`;
                row.appendChild(node);
                if (idx < steps.length - 1) {
                    const conn = document.createElement('div');
                    conn.className = 'map-connector';
                    conn.style.width = '40px'; conn.style.height = '2px'; conn.style.margin = '0 10px';
                    if (status === 'cleared') conn.classList.add('unlocked');
                    row.appendChild(conn);
                }
            });
            group.appendChild(row);
            scroll.appendChild(group);
            if (f < 8) {
                 const vConn = document.createElement('div');
                 vConn.className = 'map-connector';
                 vConn.style.height = '30px'; vConn.style.width = '2px';
                 if (this.levelIndex >= LEVEL_CONFIG.findIndex(l => l.floor === f+1)) vConn.classList.add('unlocked');
                 scroll.appendChild(vConn);
            }
        }
        map.style.display = 'flex';
        setTimeout(() => { const active = document.querySelector('.map-node.active'); if(active) active.scrollIntoView({behavior:'smooth', block:'center'}); }, 100);

        if (!this.tutorialShown) {
             this.setOverlayState(true);
             document.getElementById('tutorial-screen').classList.add('visible');
        }
    }
    
    startGame() { this.enterMapMode(); }
    
    setOverlayState(active) { if(active) document.body.classList.add('overlay-active'); else document.body.classList.remove('overlay-active'); }
    toggleAudio() { const isPlaying = this.audio.toggle(); this.isAudioOn = isPlaying; this.updateAudioBtn(isPlaying); }
    updateAudioBtn(playing) { const btn = document.getElementById('audio-toggle'); if(playing) { btn.classList.add('audio-active'); btn.style.opacity = '1'; } else { btn.classList.remove('audio-active'); btn.style.opacity = '0.5'; } }
    toggleFullscreen() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => {}); } else { if (document.exitFullscreen) { document.exitFullscreen(); } } }

    returnToLobby() { 
        this.resetGlobal(); 
        document.getElementById('overlay-screen').classList.remove('visible'); 
        this.setOverlayState(false);
        document.getElementById('lobby-screen').style.display = 'flex';
        document.getElementById('map-screen').style.display = 'none';
        document.getElementById('header-left-col').classList.add('lobby-hide');
        document.getElementById('header-right-col').classList.add('lobby-hide');
        this.inGame = false;
    }
    
    closeTutorial() {
        document.getElementById('tutorial-screen').classList.remove('visible');
        this.setOverlayState(false);
        this.tutorialShown = true;
    }

    initDOM() { 
        document.getElementById('btn-bait').onclick = () => this.confirmBait(); 
        document.getElementById('btn-combo-opp').onclick = () => this.playRound('opp'); 
        document.getElementById('btn-combo-mine').onclick = () => this.playRound('mine'); 
        document.getElementById('btn-play-hand').onclick = () => this.playRound('hand'); 
        document.getElementById('btn-skill-ok').onclick = () => this.executeSkill(); 
        document.getElementById('btn-skill-no').onclick = () => this.cancelSkill(); 
        
        const tooltip = document.getElementById('global-tooltip'); 
        
        document.body.addEventListener('mouseover', (e) => { 
            const target = e.target.closest('.passive-icon'); 
            if(target) { 
                const desc = target.getAttribute('data-desc'); 
                if(desc) { 
                    tooltip.innerText = desc; 
                    tooltip.style.display = 'block'; 
                    const rect = target.getBoundingClientRect(); 
                    
                    let finalX = rect.left + 10;
                    let finalY = rect.bottom + 10;
                    
                    if (finalX + 240 > window.innerWidth) {
                        finalX = window.innerWidth - 250;
                    }
                    if (finalY + tooltip.offsetHeight > window.innerHeight) {
                        finalY = rect.top - tooltip.offsetHeight - 10;
                    }
                    
                    tooltip.style.left = Math.max(10, finalX) + 'px'; 
                    tooltip.style.top = finalY + 'px'; 
                } 
            } 
        }); 
        document.body.addEventListener('mouseout', (e) => { 
            if(e.target.closest('.passive-icon')) tooltip.style.display = 'none'; 
        }); 

        document.addEventListener('click', (e) => {
            const bubble = document.getElementById('item-interact-bubble');
            if(bubble.style.display === 'block' && !e.target.closest('#item-interact-bubble')) {
                bubble.style.display = 'none';
            }
        });
    }

    startLevel() {
        document.getElementById('header-left-col').classList.remove('lobby-hide');
        document.getElementById('header-right-col').classList.remove('lobby-hide');
        document.getElementById('info-screen').classList.remove('visible');
        this.inGame = true;

        this.config = LEVEL_CONFIG[this.levelIndex];

        if(this.config.step === 1) { 
            this.currentLevelWins = 0; 
            this.currentLevelLosses = 0;
        }
        
        if(this.config.boss) this.bossDeck = this.createDeck();
        this.currentRound = 1; this.levelEarnedGold = 0; this.currentTargetGold = this.config.gold; 
        
        this.setupPersona();
        this.updateHeader(); this.startRound();
    }

    setupPersona() {
        const floor = this.config.floor; const step = this.config.step;
        const personas = OPPONENT_PERSONAS[floor] || OPPONENT_PERSONAS[1];
        const persona = personas[step === 1 ? 0 : 2]; 
        this.opponentName = persona.name;
        document.querySelector('.avatar').style.backgroundImage = `url('https://api.dicebear.com/7.x/bottts/svg?seed=${this.opponentName}')`;
        document.getElementById('opp-name').innerText = this.opponentName;
        const img = new Image(); img.src = `https://api.dicebear.com/7.x/bottts/svg?seed=${this.opponentName}`;
        img.onerror = () => { document.querySelector('.avatar').style.backgroundImage = "none"; document.querySelector('.avatar').innerHTML = "ğŸ¤–"; };
        setTimeout(() => this.speak(persona.text), 1500);
    }
    speak(text) {
        const bubble = document.getElementById('opp-speech'); 
        bubble.innerText = text; 
        bubble.style.opacity = 1;
        setTimeout(() => { bubble.style.opacity = 0; }, 5000);
    }

    createDeck() { 
        let deck =[]; SUITS.forEach(s => RANKS.forEach(r => deck.push(new Card(s,r)))); 
        this.shuffle(deck);
        if(this.config.rule === 'wild_6') { deck.forEach(c => { if(c.rank === '6') { c.suit = 'â™¦'; c.isRed = true; } }); } 
        return deck; 
    }
    
    startRound() {
        let deck; if(this.config.boss) { deck = this.bossDeck; } else { deck = this.createDeck(); }
        this.drawPile = this.config.boss ? deck : this.createDeck();
        this.discardPile =[];
        
        const draw = (n) => { 
            const c =[]; 
            if (this.drawPile.length < n) {
                if(this.discardPile.length > 0) {
                    this.drawPile.push(...this.discardPile);
                    this.discardPile =[];
                    this.shuffle(this.drawPile);
                } else {
                    let fresh = this.createDeck();
                    this.drawPile.push(...fresh);
                }
            }
            for(let i=0;i<n;i++) if(this.drawPile.length>0) c.push(this.drawPile.pop()); 
            return c; 
        };

        this.playerHand = draw(7).sort((a,b)=>b.value - a.value);
        
        let aiHand =[];
        const isNerfLevel = (this.config.floor <= 2 && this.config.step === 1);
        
        if (isNerfLevel) {
            let attempts = 0;
            while (attempts < 20) {
                aiHand = draw(7);
                if (!PokerEngine.isTooStrong(aiHand)) {
                    break; 
                }
                this.drawPile.push(...aiHand);
                this.shuffle(this.drawPile);
                aiHand =[];
                attempts++;
            }
            if (aiHand.length === 0) aiHand = draw(7); 
        } else {
            aiHand = draw(7);
        }
        
        this.oppHand = aiHand.sort((a,b)=>b.value - a.value);
        this.playerBait =[]; this.oppBait =[]; this.selectedCards =[]; this.selectedOppCard = null; this.skillMode = null; this.phase = 'BAIT'; this.currentBet = 0; this.betUsedThisRound = false;
        
        this.equippedSkills.forEach(k => { 
            const s = SKILLS_DB[k]; 
            if(s && s.type === 'round_limit') {
                let bonus = this.skillMaxModifiers[k] || 0;
                this.skillUsage[k] = s.maxUses + bonus;
            }
        });
        
        this.justDealt = true;
        this.updateHeader(); this.renderScene(); this.updateControls();
    }

    evalHandValue(cards) {
        const isWild = (this.config.rule === 'wild_6'); const res = PokerEngine.evaluate(cards, isWild);
        
        let base = res.base; 
        let typeBonus = 0;   
        let itemBonus = 0;   
        let mult = 0;        
        let triggeredItems =[];

        this.equippedPassives.forEach(pId => { 
            const p = REWARD_POOL.find(x => x.id === pId);
            if(!p) return;

            let triggered = false;
            if (['guchen','shuangying','sixiang','sanyuan','lianchao','yise','fulu','siji','tianlv', 'chaodie', 'xingcu', 'liuxu', 'zhanyi', 'xuanhe', 'jiyao', 'minglv'].includes(p.id)) {
                 if(p.trigger === res.name) { 
                     if (p.val) typeBonus += p.val; 
                     if (p.mult) mult += p.mult;
                     triggered = true;
                 }
            } 
            else if (p.id === 'yangyao') {
                 const count = cards.filter(c=>['A','3','5','7','9'].includes(c.rank)).length;
                 if(count > 0) { itemBonus += (base * count); triggered=true; }
            } 
            else if (p.id === 'yinyao') {
                 const count = cards.filter(c=>['2','4','6','8','10'].includes(c.rank)).length;
                 if(count > 0) { itemBonus += (base * count); triggered=true; }
            }
            else if (p.id === 'qishi') {
                 const count = cards.filter(c=>['J','Q','K'].includes(c.rank)).length;
                 if(count > 0) { itemBonus += (base * 10 * count); triggered=true; }
            }
            else if (p.trigger === 'face') { 
                 const count = cards.filter(c =>['J','Q','K'].includes(c.rank)).length;
                 if(count > 0) { mult += (p.mult * count); triggered=true; }
            }

            if(triggered && !triggeredItems.includes(p.name)) triggeredItems.push(p.name);
        });

        let row1_val = base + typeBonus;
        let total = (row1_val + itemBonus) * (1 + mult);
        let row2_val = total - row1_val;

        return { ...res, payout: total, row1: row1_val, row2: row2_val, items: triggeredItems };
    }

    renderScene() {
        const hC = document.getElementById('hand-container'); hC.innerHTML = '';
        this.playerHand.forEach((c, idx) => {
            const el = document.createElement('div'); el.innerHTML = this.htmlCard(c, false, true, false); const dom = el.firstElementChild;
            if(this.justDealt) { 
                dom.classList.add('card-deal-anim'); 
                dom.style.animationDelay = `${idx * 0.15}s`; 
                setTimeout(() => this.audio.playCardSlide(), idx * 150);
            }
            if(this.selectedCards.includes(c)) dom.classList.add('selected'); if(this.skillMode === 'yundu' || this.skillMode === 'blast') dom.style.borderColor = '#d580ff';
            if(this.config.rule === 'no_hearts' && c.suit === 'â™¥' && this.phase === 'ACTION' && this.skillMode === null) { dom.style.opacity = '0.5'; dom.style.cursor = 'not-allowed'; } else { dom.onclick = () => this.onCardClick(c); }
            hC.appendChild(dom);
        });
        if(this.justDealt) setTimeout(() => this.justDealt = false, 1500);

        const oppC = document.getElementById('opp-hand-container'); oppC.innerHTML = ''; document.getElementById('opp-count').innerText = this.oppHand.length;
        this.oppHand.forEach(c => { const show = this.config.openHand || c.revealed; 
            const el = document.createElement('div'); el.innerHTML = this.htmlCard(c, true, show, false); const dom = el.firstElementChild;
            if(this.selectedOppCard && this.selectedOppCard.id===c.id) dom.classList.add('opp-selected');
            if(this.skillMode==='blast') dom.onclick = ()=>this.onOppCardClick(c);
            oppC.appendChild(dom);
        });
        const myB = document.getElementById('my-bait-container'); const oppB = document.getElementById('opp-bait-container');
        myB.innerHTML = this.playerBait.length===0 ? '<div class="slot-placeholder"></div><div class="slot-placeholder"></div>' : '';
        this.playerBait.forEach(c => myB.innerHTML += this.htmlCard(c, false, true, false));
        oppB.innerHTML = this.oppBait.length===0 ? '<div class="slot-placeholder"></div><div class="slot-placeholder"></div>' : '';
        const baitVis = (this.phase === 'ACTION') || this.config.openHand;
        this.oppBait.forEach(c => {
             const vis = (this.phase === 'ACTION') || this.config.openHand || c.revealed;
             oppB.innerHTML += this.htmlCard(c, false, vis, false);
        });
        this.renderSkills();
    }
    htmlCard(c, mini, face, isBait) {
        if(!face) return `<div class="card ${mini?'mini':''} card-back"></div>`;
        const badge = isBait ? `<div class="badge-bait">æ”¾</div>` : '';
        return `<div class="card ${mini?'mini':''} ${c.isRed?'red':'black'}"><div class="card-rank">${c.rank}</div><div class="card-suit">${c.suit}</div>${badge}</div>`;
    }

    renderSkills() {
        const div = document.getElementById('skill-dock'); div.innerHTML = '';
        this.equippedSkills.forEach(k => {
            const s = SKILLS_DB[k]; if(!s) return; const el = document.createElement('div'); el.className = 'skill-item';
            let dis = false; let count = '';
            
            if(s.type === 'limit' || s.type === 'item_active' || s.type === 'round_limit' || s.type === 'level_limit' || s.type === 'consumable') {
                count = this.skillUsage[k] !== undefined ? this.skillUsage[k] : 0; 
                if(count<=0) dis = true;
            } else if (s.type === 'once_per_round') {
                if(k==='huanzhu' && !this.config.boss) dis = true; else if (this.betUsedThisRound && k==='huanzhu') dis = true;
            }
            if(k === 'xinjing' && this.oppBait.length > 0 && this.oppBait[0].revealed) dis = true;
            if(k === 'xinjing' && this.phase !== 'BAIT') dis = true;

            if(dis) el.classList.add('disabled'); el.setAttribute('data-desc', dis&&k==='huanzhu'&&this.betUsedThisRound ? "æœ¬å›åˆå·²ä½¿ç”¨" : s.desc);
            const icon = s.icon || 'ğŸ”°';
            el.innerHTML = `<div style="font-size:20px">${icon}</div><div style="font-size:10px">${s.name}</div>${count!==''?`<div class="skill-count">${count}</div>`:''}`;
            el.onclick = () => { if(!dis) this.activateSkill(k); }
            div.appendChild(el);
        });
    }

    updateControls() {
        const bait=document.getElementById('btn-bait'); const play=document.getElementById('play-group'); const skill=document.getElementById('skill-confirm-group'); const bet=document.getElementById('bet-panel'); const tip=document.getElementById('phase-tip');
        bait.style.display='none'; play.style.display='none'; skill.style.display='none'; bet.style.display='none';
        if(this.skillMode) {
            if(this.skillMode==='huanzhu') {
                document.querySelector('#bet-panel button:nth-child(2)').innerText = `ä¸‹æ³¨ ${(this.betRatios[0]*100)}%`; document.querySelector('#bet-panel button:nth-child(2)').onclick = () => game.placeBet(0);
                document.querySelector('#bet-panel button:nth-child(3)').innerText = `ä¸‹æ³¨ ${(this.betRatios[1]*100)}%`; document.querySelector('#bet-panel button:nth-child(3)').onclick = () => game.placeBet(1);
                bet.style.display='flex'; return; 
            }
            skill.style.display='flex'; document.getElementById('skill-desc-text').innerText = SKILLS_DB[this.skillMode].desc;
            const ok = document.getElementById('btn-skill-ok');
            if(['yundu','blast'].includes(this.skillMode)) ok.disabled = this.selectedCards.length!==1; else if(this.skillMode==='xuanji') ok.disabled = this.selectedCards.length===0; else ok.disabled = false;
            return;
        }
        if(this.phase==='BAIT') {
            tip.innerText = 'è¯·é€‰æ‹© 2 å¼ ä½œä¸ºè¯±é¥µ (å¯å…ˆç”¨æŠ€èƒ½)'; bait.style.display='block'; bait.innerText = `æ”¾å…¥è¯±é¥µ (${this.selectedCards.length}/2)`; bait.disabled = this.selectedCards.length!==2;
        } else {
            tip.innerText = 'ç»„åˆå‡ºç‰Œé˜¶æ®µ'; play.style.display='flex';
            const n = this.selectedCards.length; const b1=document.getElementById('btn-combo-opp'); const b2=document.getElementById('btn-combo-mine'); const b3=document.getElementById('btn-play-hand');
            b1.disabled=b2.disabled=(n!==3); b3.disabled=(n!==5);
            const isWild = (this.config.rule === 'wild_6');
            if(n===3) {
                const r1 = this.evalHandValue([...this.selectedCards, ...this.oppBait], isWild); const r2 = this.evalHandValue([...this.selectedCards, ...this.playerBait], isWild);
                b1.innerHTML = `å’Œtaç»„åˆ å‡º ${r1.name} <span class="gold-val">(${r1.payout}åˆ†)</span>`; b2.innerHTML = `è‡ªå·±ç»„åˆ å‡º ${r2.name} <span class="gold-val">(${r2.payout}åˆ†)</span>`;
            } else { b1.innerText='å’Œ TA è¯±é¥µç»„åˆ'; b2.innerText='å’Œ æˆ‘çš„ è¯±é¥µç»„åˆ'; }
            if(n===5) {
                const r3 = this.evalHandValue(this.selectedCards, isWild); b3.innerHTML = `å‡º ${r3.name} <span class="gold-val">(${r3.payout}åˆ†)</span>`;
            } else { b3.innerText='ç›´æ¥å‡º 5 å¼ æ‰‹ç‰Œ'; }
        }
    }

    onCardClick(c) {
        if(this.config.rule === 'no_hearts' && c.suit === 'â™¥' && this.phase === 'ACTION' && !this.skillMode) return;
        this.audio.playTick();
        if(this.skillMode) {
            if(['yundu','blast'].includes(this.skillMode)) this.selectedCards=[c]; else if(this.skillMode==='xuanji') { const i=this.selectedCards.indexOf(c); if(i>-1)this.selectedCards.splice(i,1); else if(this.selectedCards.length<5)this.selectedCards.push(c); }
            this.renderScene(); this.updateControls(); return;
        }
        const i=this.selectedCards.indexOf(c); if(i>-1)this.selectedCards.splice(i,1); else { const max = this.phase==='BAIT'?2:5; if(this.selectedCards.length<max)this.selectedCards.push(c); }
        this.renderScene(); this.updateControls();
    }
    onOppCardClick(c) {
        if (this.skillMode !== 'blast') return;
        if (!c.revealed && !this.config.openHand) { alert("æ— æ³•é€‰ä¸­æš—ç‰Œï¼è¯·å…ˆæ˜ç‰Œæˆ–ç­‰å¾…æ—¶æœºã€‚"); return; }
        this.audio.playTick();
        this.selectedOppCard = c; this.renderScene(); this.updateControls();
    }

    confirmBait() { 
        this.playerBait =[...this.selectedCards]; 
        this.playerHand = this.playerHand.filter(c=>!this.selectedCards.includes(c)); 
        this.selectedCards =[]; 
        if (this.oppBait.length === 0) {
            const strategy = PokerEngine.getStrategicBait(this.oppHand, this.config.boss);
            this.oppBait = strategy.bait; 
            this.oppHand = strategy.keep; 
            if (this.config.openHand) this.oppBait.forEach(c=>c.revealed=true);
        }
        this.phase = 'ACTION'; 
        this.renderScene(); this.updateControls(); 
    }

    playRound(type) {
        let cards =[], baitSrc = 'none';
        if(type==='opp') { cards =[...this.selectedCards, ...this.oppBait]; baitSrc='opp'; } else if(type==='mine') { cards=[...this.selectedCards, ...this.playerBait]; baitSrc='mine'; } else cards=[...this.selectedCards];
        const isWild = (this.config.rule === 'wild_6'); const myRes = this.evalHandValue(cards); 
        const aiBestMine = PokerEngine.getBestCombo(this.oppHand, this.playerBait, isWild); const aiBestOpp  = PokerEngine.getBestCombo(this.oppHand, this.oppBait, isWild); const aiDirect = PokerEngine.evaluate(this.oppHand, isWild); 
        const aiOpts =[{ t:'mine', ...aiBestMine }, { t:'opp', ...aiBestOpp }, { t:'none', ...aiDirect }]; aiOpts.sort((a,b)=>b.rawScore - a.rawScore); const aiRes = aiOpts[0];
        const win = myRes.rawScore > aiRes.rawScore; let fish = false;
        
        let finalPayout = 0;

        if(win) {
            this.currentLevelWins++; 
            fish = (baitSrc==='mine' && aiRes.t==='mine');
            let totalHandVal = myRes.payout;
            
            let fishMult = 2;
            if (this.equippedPassives.includes('fishhook')) fishMult = 3;
            if (fish) totalHandVal *= fishMult; 

            let betRefund = 0;
            let betProfit = 0;
            if (this.currentBet > 0) {
                betRefund = this.currentBet;
                betProfit = this.currentBet; 
            }

            finalPayout = Math.floor(totalHandVal * 0.10) + betRefund + betProfit;
        } else {
            this.currentLevelLosses++; 
            if(this.currentBet > 0) this.currentTargetGold += this.currentBet;
        }

        let fishMultBase = this.equippedPassives.includes('fishhook') ? 3 : 2;
        let checkReward = (win ? (myRes.payout * (fish ? fishMultBase : 1)) : 0); 

        this.levelEarnedGold += checkReward; 
        
        this.playerGold += finalPayout; 
        this.updateHeader();
        
        let pass = false; 
        if(this.config.target === 'best_of_3') pass = this.currentLevelWins >= 2; 
        else if(this.config.target==='accumulate') pass = this.levelEarnedGold >= this.currentTargetGold;
        
        let failReason = "";
        
        if (!win && this.config.target === 'best_of_3') failReason = "æœ¬å±€å¤±è´¥"; 
        
        let isEarlyExitWin = (this.config.target === 'best_of_3' && this.currentLevelWins >= 2);
        let isEarlyExitLoss = (this.config.target === 'best_of_3' && this.currentLevelLosses >= 2);

        if (this.currentRound === 3 && !pass) {
             if (this.config.target === 'best_of_3') failReason = `èƒœåœºä¸è¶³ (${this.currentLevelWins}/3)`;
             else if (this.config.target === 'accumulate') failReason = `æ€»ç§¯åˆ†ä¸è¶³`;
        }

        if(this.config.target === 'accumulate') {
            if(pass) this.showSettlePanel(true, myRes, aiRes, finalPayout, cards, aiRes.cards, baitSrc, aiRes.t, fish, true, "", checkReward);
            else if(this.currentRound < 3) this.showSettlePanel(win, myRes, aiRes, finalPayout, cards, aiRes.cards, baitSrc, aiRes.t, fish, false, "", checkReward);
            else this.showFailPanel(myRes, aiRes, cards, aiRes.cards, failReason, checkReward); 
        } else {
             if (isEarlyExitLoss) {
                let earlyFailReason = `èƒœåœºä¸è¶³ (${this.currentLevelWins}/3)`;
                this.showFailPanel(myRes, aiRes, cards, aiRes.cards, earlyFailReason, checkReward);
             } 
             else if (isEarlyExitWin) {
                this.showSettlePanel(true, myRes, aiRes, finalPayout, cards, aiRes.cards, baitSrc, aiRes.t, fish, true, "", checkReward);
             }
             else if(this.currentRound < 3) {
                 this.showSettlePanel(win, myRes, aiRes, finalPayout, cards, aiRes.cards, baitSrc, aiRes.t, fish, false, "", checkReward);
             }
             else if (pass) {
                 this.showSettlePanel(true, myRes, aiRes, finalPayout, cards, aiRes.cards, baitSrc, aiRes.t, fish, true, "", checkReward);
             }
             else {
                 this.showFailPanel(myRes, aiRes, cards, aiRes.cards, failReason, checkReward);
             }
        }
    }

    animateGold(target) {
        const el = document.getElementById('settle-gold-num');
        if(!el) return;
        let start = 0;
        const duration = 1500;
        const startTime = performance.now();
        const step = (now) => {
            const elapsed = now - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const ease = 1 - Math.pow(1 - progress, 3); 
            const current = Math.floor(start + (target - start) * ease);
            el.innerText = current;
            
            if(progress < 1 && Math.random() > 0.8) this.audio.playCoin();

            if(progress < 1) requestAnimationFrame(step);
            else el.innerText = target;
        };
        requestAnimationFrame(step);
    }

    showSettlePanel(win, myRes, aiRes, gold, myCards, aiCards, mySrc, aiSrc, fish, isEnd, failMsg, levelVal) {
        const ov = document.getElementById('overlay-screen'); 
        ov.classList.add('visible');
        this.setOverlayState(true);

        if(win) this.audio.playWin();
        else this.audio.playLose();

        const myTitle = win ? `${myRes.name} èƒœ` : `${myRes.name}`; const titleCls = win ? "win-title-tag" : "lose-title-tag";
        const getHTML = (cards) => { let h = ''; const allBait =[...this.playerBait, ...this.oppBait]; cards.forEach(c => { const isB = allBait.some(b => b.id === c.id); h += this.htmlCard(c, true, true, !!isB); }); return h; };
        
        const usedBait = mySrc==='mine'?this.playerBait:this.oppBait;
        const baitStr = usedBait.length>0 ? usedBait.map(c=>c.suit+c.rank).join(' ') : '';
        const baitTxt = mySrc==='mine' ? `ä½¿ç”¨è¯±é¥µï¼šæˆ‘çš„è¯±é¥µç‰Œ ${baitStr}` : (mySrc==='opp' ? `ä½¿ç”¨è¯±é¥µï¼šå¯¹æ‰‹çš„è¯±é¥µç‰Œ ${baitStr}` : 'æœªä½¿ç”¨è¯±é¥µ');
        let fishMultBase = this.equippedPassives.includes('fishhook') ? 3 : 2;
        const fishTxt = fish ? `<span style="color:var(--highlight)">é’“é±¼æˆåŠŸx${fishMultBase} + ç§¯åˆ†${myRes.payout}</span>` : 'æ— è¯±é¥µå¥–åŠ±';

        let nextAction = isEnd ? `game.openShopInventory()` : "game.nextRound()"; 
        let btnTxt = isEnd ? "å‰å¾€é“å…·å•†åº—" : "ä¸‹ä¸€å›åˆ";

        if(isEnd && this.levelIndex >= LEVEL_CONFIG.length - 1 && win) { ov.innerHTML = `<div style="text-align:center; color:gold;"><div style="font-size:60px;">ğŸ¦Š</div><h1>æ— å°½å¡”æ¥¼ï¼ŒæŒ‘æˆ˜æˆåŠŸ</h1><p>æ­å–œè·å¾—ç‹ç‹¸å¾½ç« </p><button class="btn btn-primary" style="width:200px; margin-top:20px;" onclick="game.returnToLobby()">è¿”å›å¤§å…</button></div>`; return; }

        let tagsHTML = ''; 
        if(win) { 
            if(fish) tagsHTML += `<div class="score-tag tag-fish" style="opacity:1; transform:scale(1);">ğŸ£ é’“é±¼ x${fishMultBase}</div>`; 
            this.equippedPassives.forEach(pId => { 
                const p = REWARD_POOL.find(x => x.id === pId);
                if (p && (p.trigger === myRes.name || p.trigger === 'odd' || p.trigger === 'even' || p.trigger === 'face' || (fish && p.trigger === 'fishhook'))) { 
                   tagsHTML += `<div class="passive-icon" data-desc="${p.name}: ${p.desc}" style="opacity:1; transform:scale(1); margin-right: 5px;">${p.icon}</div>`; 
                }
            }); 
        }
        
        const row1 = myRes.row1;
        const row2 = myRes.row2;
        const itemsStr = myRes.items.length > 0 ? myRes.items.join(', ') : 'æ— ';

        let progressStr = '';
        if (this.config.target === 'accumulate') progressStr = `${Math.floor(this.levelEarnedGold)}/${this.currentTargetGold}`;
        else if (this.config.target === 'best_of_3') progressStr = `${this.currentLevelWins} èƒœ ${this.currentLevelLosses} è´Ÿ`;
        
        const progressTxt = progressStr ? `<div style="text-align:right; font-size:12px; color:#fff; margin-top:5px;">æœ¬å…³è¿›åº¦: ${progressStr}</div>` : '';

        ov.innerHTML = `
        <div class="settle-modal">
            <div class="settle-header"><div>${win?'å›åˆèƒœåˆ©':'å›åˆå¤±è´¥'}</div><div class="multiplier-bar" style="font-size:16px;">æœ¬å±€è·å¾—ï¼šğŸ’° <span id="settle-gold-num">0</span></div></div>
            <div class="settle-content">
                <div class="settle-left"><div class="avatar" style="background-image: url('https://api.dicebear.com/7.x/bottts/svg?seed=${this.opponentName}')"></div><div class="result-badge">${aiRes.name}</div><div class="cards-display-row">${getHTML(aiCards)}</div><div style="font-size:10px; color:#666;">å¯¹æ‰‹æœ€ç»ˆç‰Œå‹</div></div>
                <div class="settle-right">
                    <div class="${titleCls}" style="display:flex; justify-content:space-between; width:100%; align-items:center;">
                        <span>${myTitle}</span>
                        ${progressTxt}
                    </div>
                    <div class="cards-display-row" style="transform:scale(1.1); margin:5px 0;">${getHTML(myCards)}</div>
                    <div style="width:100%; margin-top:10px; display:flex; flex-direction:column; gap:5px;">
                        <div class="detail-row">
                            <span>æˆ‘çš„ç‰Œå‹ï¼š${myRes.name}</span>
                            <span class="gold-val">ç§¯åˆ† +${row1}</span>
                        </div>
                        <div class="detail-row" style="background:rgba(255,255,255,0.03);">
                            <span>é“å…·åŠ å€ï¼š${itemsStr}</span>
                            <span class="gold-val">ç§¯åˆ† +${Math.floor(row2)}</span>
                        </div>
                        <div class="detail-row" style="background:rgba(255,255,255,0.03);">
                            <span style="font-size:12px; color:#fff; max-width:50%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${baitTxt}</span>
                            <span>${fishTxt}</span>
                        </div>
                    </div>
                    <div class="tags-container" style="flex-wrap:wrap; opacity:1; min-height: 25px;">${tagsHTML}</div>
                </div>
            </div>
            <div class="settle-footer"><button class="btn btn-primary" style="width:200px; margin:0 auto;" onclick="${nextAction}">${btnTxt}</button></div>
        </div>`;

        if(win) this.animateGold(gold);
    }

    showFailPanel(myRes, aiRes, myCards, aiCards, reason, levelVal) { 
        this.audio.playLose();
        this.setOverlayState(true);
        const ov = document.getElementById('overlay-screen'); 
        ov.classList.add('visible');

        const getHTML = (cards) => cards.map(c => this.htmlCard(c, true, true, false)).join('');

        let leftInfo = `<div style="color:#e74c3c; font-weight:bold; text-align:center; font-size:14px; background:rgba(0,0,0,0.3); padding:10px; border-radius:4px; width:100%;">${reason}</div>`;
        
        let progressInfo = '';
        if (this.config.target === 'accumulate') progressInfo = `æœ¬å±€ç§¯åˆ†: ${Math.floor(levelVal)} / ç´¯è®¡ç§¯åˆ†: ${Math.floor(this.levelEarnedGold)}/${this.currentTargetGold}`;
        else if (this.config.target === 'best_of_3') progressInfo = `å½“å‰æˆ˜ç»©: ${this.currentLevelWins} èƒœ ${this.currentLevelLosses} è´Ÿ`;
        
        if(progressInfo) leftInfo += `<div style="margin-top:10px; color:#ddd; font-size:12px;">${progressInfo}</div>`;

        ov.innerHTML = `
        <div class="settle-modal" style="border-color:var(--danger)">
            <div class="settle-header" style="background:#400;">å›åˆå¤±è´¥</div>
            <div class="settle-content">
                <div class="settle-left" style="justify-content:center; gap:20px;">
                    <h2 style="color:var(--danger); font-size:24px; text-align:center; line-height:1.4;">ç­‰ç€å§ï½<br>æˆ‘ä¼šèµ¢å›æ¥çš„ï¼</h2>
                    ${leftInfo}
                </div>
                <div class="settle-right" style="justify-content:flex-start; gap:15px;">
                    <div style="text-align:center;">
                        <div style="font-size:12px; color:#aaa; margin-bottom:5px;">å¯¹æ‰‹: ${aiRes.name}</div>
                        <div class="cards-display-row">${getHTML(aiCards)}</div>
                    </div>
                    <div style="text-align:center; border-top:1px solid rgba(255,255,255,0.1); padding-top:15px;">
                        <div style="font-size:12px; color:#888; margin-bottom:5px;">æˆ‘çš„: ${myRes.name}</div>
                        <div class="cards-display-row">${getHTML(myCards)}</div>
                    </div>
                </div>
            </div>
            <div class="settle-footer">
                <button class="btn btn-primary" style="width:200px; margin:0 auto;" onclick="game.showFailScreen()">ç¡®å®š</button>
            </div>
        </div>`;
    }
    showFailScreen() { const ov = document.getElementById('overlay-screen'); ov.innerHTML = `<div class="msg-screen-content"><div class="msg-title">æŒ‘æˆ˜å¤±è´¥</div><div class="msg-subtitle">æ— å°½å¡”æ¥¼çš„è¯•ç‚¼è¿˜åœ¨ç»§ç»­...</div><button class="btn btn-lobby" onclick="game.returnToLobby()">å›åˆ°å¤§å…</button></div>`; }
    
    // --- Shop & Inventory Logic (v3.2.2) ---
    openShopInventory() {
        document.getElementById('overlay-screen').classList.remove('visible'); 
        
        const modal = document.getElementById('shop-screen');
        modal.style.display = 'flex';
        this.setOverlayState(true);
        
        this.availablePacks =['upgrade', 'skill', 'normal'];
        this.shopDirectItems = this.generateRandomItems(3);
        
        this.switchShopTab('shop');
        this.renderEquipCircle();
    }

    generateRandomItems(count) {
        const pool =[...REWARD_POOL];
        const available = pool.filter(i => {
            if (i.unique && (this.ownedSkills.includes(i.ref || i.id) || this.ownedPassives.includes(i.id))) return false;
            if (i.type === 'upgrade') {
                if (['yunyan','xuanshu','huance','xinyu'].includes(i.id) && (this.upgradeCounts[i.id]||0) >= 2) return false;
                if (i.id === 'yunyan' && !this.ownedSkills.includes('yundu')) return false;
                if (i.id === 'xuanshu' && !this.ownedSkills.includes('xuanji')) return false;
                if (i.id === 'huance' && !this.ownedSkills.includes('huanzhu')) return false;
            }
            return true;
        });
        
        this.shuffle(available);
        let res =[];
        for(let i=0; i<count; i++) {
            if(available[i]) {
                res.push({...available[i], _purchased: false, _uid: Math.random().toString(36).slice(2)});
            }
        }
        return res;
    }

    switchShopTab(tab) {
        document.querySelectorAll('.shop-tab').forEach(el => el.classList.remove('active'));
        document.getElementById('tab-btn-' + tab).classList.add('active');
        
        document.getElementById('tab-content-shop').style.display = 'none';
        document.getElementById('tab-content-inventory').style.display = 'none';
        document.getElementById('tab-content-' + tab).style.display = 'block';
        
        document.getElementById('shop-modal-gold').innerText = this.playerGold;

        if (tab === 'shop') {
            this.renderShopHome();
        } else {
            this.renderInventory();
        }
    }

    renderShopHome() {
        const ct = document.getElementById('tab-content-shop');
        let discount = (this.config.floor === 1) ? 0.1 : 1;
        
        let html = '<div style="display:flex; flex-direction:column; overflow-y:auto; height:100%; padding-bottom:20px;">';
        
        // Direct Items 
        html += `<div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-start; padding-bottom: 10px;">`;
        if (this.shopDirectItems.length === 0) {
            html += `<div style="text-align:center; width:100%; color:#888; padding: 20px;">æš‚æ— é“å…·å¯è´­ä¹°</div>`;
        } else {
            this.shopDirectItems.forEach(r => {
                let basePrice = typeof r.getPrice === 'function' ? r.getPrice(this) : r.price;
                let price = Math.max(1, Math.floor(basePrice * discount));
                const canBuy = this.playerGold >= price;
                const isPurchased = r._purchased;
                const btnStyle = isPurchased ? 'btn' : (canBuy ? 'btn-primary' : 'btn');
                const btnState = (isPurchased || !canBuy) ? 'disabled' : '';
                
                let isConsumable = r.type === 'item_active' && r.ref && SKILLS_DB[r.ref] && SKILLS_DB[r.ref].type === 'consumable';
                const btnTxt = isPurchased ? 'å·²è´­ä¹°' : (isConsumable ? `ğŸ’° ${price}/1 æ¬¡` : `ğŸ’° ${price} è´­ä¹°`);
                
                let discountBadge = discount < 1 ? `<div style="position:absolute; top:4px; right:4px; background:var(--danger); color:#fff; font-size:10px; padding:2px 4px; border-radius:4px; font-weight:bold; z-index:10; box-shadow:0 2px 5px rgba(0,0,0,0.5);">1æŠ˜å‡ºå”®</div>` : '';

                html += `
                <div class="reward-card" id="rcard-${r._uid}" style="width: calc(33.33% - 10px); min-width: 110px; padding: 10px; height: 190px; ${isPurchased ? 'border: 2px solid var(--gold-color); opacity: 0.6;' : ''}">
                    ${discountBadge}
                    <div style="font-size:30px; margin-bottom:5px;">${r.icon || 'ğŸ”°'}</div>
                    <div style="color:var(--highlight); font-weight:bold; margin-bottom:5px; font-size:12px;">${r.name}</div>
                    <div style="font-size:10px; color:#ccc; margin-bottom:10px; flex:1; display:flex; align-items:center; justify-content:center; line-height:1.4;">${r.desc}</div>
                    <button class="btn ${btnStyle}" id="buy-btn-${r._uid}" ${btnState} onclick="game.buyShopItem('${r._uid}', ${price})" style="width:100%; padding: 6px 0; font-size: 11px; flex-shrink:0;">${btnTxt}</button>
                </div>`;
            });
        }
        html += '</div>';

        // Divider
        html += `<div style="width: 100%; border-top: 1px dashed rgba(255,255,255,0.2); margin: 15px 0;"></div>`;

        // Packs 
        if (this.availablePacks.length > 0) {
            html += `<div style="display: flex; flex-wrap: wrap; justify-content: flex-start; gap: 10px;">`;
            
            const packDefs = {
                'upgrade': { icon: 'ğŸ†™', name: 'å‡çº§åŒ…', desc: 'éšæœº1~3å¼ å‡çº§å¡', color: 'var(--gold-color)' },
                'skill': { icon: 'ğŸ”®', name: 'æŠ€èƒ½åŒ…', desc: 'éšæœº1å¼ æŠ€èƒ½å¡', color: 'var(--rare)' },
                'normal': { icon: 'ğŸ’', name: 'é“å…·åŒ…', desc: 'éšæœº2å¼ æ™®é€šé“å…·', color: 'var(--highlight)' }
            };

            let packBasePrice = 100;
            let packPrice = Math.max(1, Math.floor(packBasePrice * discount));
            let packDiscountBadge = discount < 1 ? `<div style="position:absolute; top:-8px; right:-8px; background:var(--danger); color:#fff; font-size:10px; padding:2px 4px; border-radius:6px; font-weight:bold; transform:rotate(15deg); z-index:10; box-shadow:0 2px 5px rgba(0,0,0,0.5);">1æŠ˜å‡ºå”®</div>` : '';

            this.availablePacks.forEach(p => {
                const def = packDefs[p];
                const canAffordPack = this.playerGold >= packPrice;
                const opac = canAffordPack ? 1 : 0.5;
                html += `
                <div class="pack-card" style="padding: 10px; width: calc(33.33% - 10px); max-width: 130px; opacity: ${opac}; display: flex; flex-direction: column; align-items: center; justify-content: center; position:relative;" onclick="game.openPack('${p}', ${packPrice})">
                    ${packDiscountBadge}
                    <div style="background: rgba(0,0,0,0.5); border: 1px solid var(--gold-color); color: var(--gold-color); font-size: 10px; padding: 2px 6px; border-radius: 10px; margin-bottom: 5px; white-space: nowrap;">ğŸ’° ${packPrice} å¼€å¯</div>
                    <div style="font-size: 30px;">${def.icon}</div>
                    <div style="font-weight: bold; margin-top:5px; font-size:12px; color: ${def.color};">${def.name}</div>
                    <div style="font-size:9px; color:#888; margin-top:3px;">${def.desc}</div>
                </div>`;
            });
            
            html += `</div>`;
        } else {
            html += `<div style="text-align:center; padding: 15px; color:#666; font-size:12px;">æ‰€æœ‰å¡åŒ…å·²å¼€å¯</div>`;
        }

        html += '</div>';
        ct.innerHTML = html;
    }

    openPack(type, price) {
        if (this.playerGold < price) { 
            alert("é‡‘å¸ä¸è¶³ï¼Œæ— æ³•å¼€å¯å¡åŒ…ï¼"); 
            return; 
        }
        
        this.playerGold -= price;
        document.getElementById('shop-modal-gold').innerText = this.playerGold;
        this.updateHeader();

        this.availablePacks = this.availablePacks.filter(p => p !== type);

        const pool =[...REWARD_POOL];
        const available = pool.filter(i => {
            if (i.unique && (this.ownedSkills.includes(i.ref || i.id) || this.ownedPassives.includes(i.id))) return false;
            if (i.type === 'upgrade') {
                if (['yunyan','xuanshu','huance','xinyu'].includes(i.id) && (this.upgradeCounts[i.id]||0) >= 2) return false;
                if (i.id === 'yunyan' && !this.ownedSkills.includes('yundu')) return false;
                if (i.id === 'xuanshu' && !this.ownedSkills.includes('xuanji')) return false;
                if (i.id === 'huance' && !this.ownedSkills.includes('huanzhu')) return false;
            }
            return true;
        });
        
        let targetType = '';
        let count = 1;
        if (type === 'upgrade') { targetType = 'upgrade'; count = Math.floor(Math.random()*3)+1; } 
        else if (type === 'skill') { targetType = 'item_active'; count = 1; }
        else if (type === 'normal') { targetType = 'passive'; count = 2; }
        
        let candidates = available.filter(i => i.type === targetType);
        this.shuffle(candidates);
        
        let newItems =[];
        for(let i=0; i<count; i++) {
            if(candidates[i]) newItems.push({ ...candidates[i], _purchased: false, _uid: Math.random().toString(36).slice(2) });
        }
        
        this.shopDirectItems =[...newItems, ...this.shopDirectItems];
        this.renderShopHome();
    }

    buyShopItem(uid, price) {
        if (this.playerGold < price) return;
        
        this.playerGold -= price;
        document.getElementById('shop-modal-gold').innerText = this.playerGold;
        this.updateHeader();

        const r = this.shopDirectItems.find(x => x._uid === uid);
        if (!r) return;
        r._purchased = true;

        if (r.type === 'upgrade') {
            if(r.id === 'yunyan') { this.skillMaxModifiers.yundu += 1; if(this.skillUsage.yundu!==undefined) this.skillUsage.yundu += 1; this.upgradeCounts.yunyan = (this.upgradeCounts.yunyan||0)+1; }
            else if(r.id === 'xuanshu') { this.skillMaxModifiers.xuanji += 1; if(this.skillUsage.xuanji!==undefined) this.skillUsage.xuanji += 1; this.upgradeCounts.xuanshu = (this.upgradeCounts.xuanshu||0)+1; }
            else if(r.id === 'huance') { if(this.betRatios[0] === 0.3) this.betRatios =[0.4, 0.6]; else if(this.betRatios[0] === 0.4) this.betRatios =[0.5, 0.7]; this.upgradeCounts.huance = (this.upgradeCounts.huance||0)+1; }
            else if(r.id === 'xinyu') { this.maxSkillSlots++; this.upgradeCounts.xinyu = (this.upgradeCounts.xinyu||0)+1; this.renderEquipCircle(); }
        } else if (r.type === 'item_active') {
            if (!this.ownedSkills.includes(r.ref)) {
                this.ownedSkills.unshift(r.ref); 
            }
            
            const s = SKILLS_DB[r.ref];
            if (s && s.type === 'consumable') {
                this.skillUsage[r.ref] = (this.skillUsage[r.ref] || 0) + 1;
            }

            if (this.equippedSkills.length < this.maxSkillSlots && !this.equippedSkills.includes(r.ref)) {
                this.equippedSkills.push(r.ref);
                this.renderEquipCircle();
            }
        } else {
            this.ownedPassives.unshift(r.id);
            if (this.equippedPassives.length < this.maxPassiveSlots && !this.equippedPassives.includes(r.id)) {
                this.equippedPassives.push(r.id);
                this.renderEquipCircle();
            }
        }

        const btn = document.getElementById('buy-btn-'+uid);
        if(btn) {
            btn.innerText = "å·²è´­ä¹°";
            btn.disabled = true;
            btn.classList.remove('btn-primary');
        }
        
        const card = document.getElementById('rcard-'+uid);
        if(card) {
            card.style.border = '2px solid var(--gold-color)';
            card.style.opacity = '0.6';
        }
        
        this.updateShopButtons();
    }

    updateShopButtons() {
        let discount = (this.config.floor === 1) ? 0.1 : 1;
        this.shopDirectItems.forEach(item => {
            if(!item._purchased) {
               const btn = document.getElementById('buy-btn-'+item._uid);
               if(btn) {
                   let basePrice = typeof item.getPrice === 'function' ? item.getPrice(this) : item.price;
                   let price = Math.max(1, Math.floor(basePrice * discount));
                   if(this.playerGold < price) {
                       btn.disabled = true;
                       btn.classList.remove('btn-primary');
                   }
               }
            }
        });
    }

    renderEquipCircle() {
        const container = document.getElementById('equip-circle-container');
        let html = '<div id="equip-circle-wrapper" style="position:absolute; width:100%; height:100%; left:0; top:0;">';
        
        const sR = 55; // Inner radius
        const pR = 130; // Outer radius
        
        // Background and visual style layers
        html += `<div style="position: absolute; width: ${pR * 2}px; height: ${pR * 2}px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.05); background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,0.4) 100%); box-shadow: inset 0 0 30px rgba(0,0,0,0.8); pointer-events: none; left: 50%; top: 50%; transform: translate(-50%, -50%);"></div>`;
        html += `<div style="position: absolute; width: ${sR * 2 + 20}px; height: ${sR * 2 + 20}px; border-radius: 50%; border: 1px dashed rgba(213,128,255,0.3); background: radial-gradient(circle, rgba(213,128,255,0.1) 0%, rgba(0,0,0,0) 70%); pointer-events: none; left: 50%; top: 50%; transform: translate(-50%, -50%);"></div>`;
        html += `<div style="position: absolute; width: 30px; height: 30px; border-radius: 50%; background: var(--rare); opacity: 0.1; box-shadow: 0 0 20px var(--rare); pointer-events: none; left: 50%; top: 50%; transform: translate(-50%, -50%);"></div>`;
        
        // Connecting lines overlay
        html += `<svg style="position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 0;">`;
        for(let i=0; i<this.maxPassiveSlots; i++) {
            const angle = (i * 360 / this.maxPassiveSlots) * (Math.PI / 180) - Math.PI / 2;
            const x1 = 50 + Math.cos(angle) * 15; 
            const y1 = 50 + Math.sin(angle) * 15;
            const x2 = 50 + Math.cos(angle) * 45; 
            const y2 = 50 + Math.sin(angle) * 45;
            html += `<line x1="${x1}%" y1="${y1}%" x2="${x2}%" y2="${y2}%" stroke="rgba(255,255,255,0.05)" stroke-width="1" />`;
        }
        html += `</svg>`;

        // Skills (Inner Circle)
        for(let i=0; i<this.maxSkillSlots; i++) {
            const angle = (i * 360 / this.maxSkillSlots) * (Math.PI / 180) - Math.PI / 2;
            const x = Math.cos(angle) * sR;
            const y = Math.sin(angle) * sR;
            const skillId = this.equippedSkills[i];
            let content = '', cls = 'normal';
            if (skillId) {
                const s = SKILLS_DB[skillId];
                content = s ? s.icon : '';
                cls = 'filled';
            }
            html += `<div class="equip-slot ${cls}" style="transform: translate(calc(-50% + ${x}px), calc(-50% + ${y}px));" onclick="game.clickEquipSlot('skill', ${i}, event)">${content}</div>`;
        }
        
        // Passives (Outer Circle)
        for(let i=0; i<this.maxPassiveSlots; i++) {
            const angle = (i * 360 / this.maxPassiveSlots) * (Math.PI / 180) - Math.PI / 2;
            const x = Math.cos(angle) * pR;
            const y = Math.sin(angle) * pR;
            const passId = this.equippedPassives[i];
            let content = '', cls = '';
            if (passId) {
                const p = REWARD_POOL.find(x => x.id === passId);
                content = p ? p.icon : '';
                cls = 'filled';
            }
            html += `<div class="equip-slot ${cls}" style="transform: translate(calc(-50% + ${x}px), calc(-50% + ${y}px));" onclick="game.clickEquipSlot('passive', ${i}, event)">${content}</div>`;
        }
        
        html += '</div>'; // End wrapper
        container.innerHTML = html;
    }

    renderInventory() {
        const ct = document.getElementById('tab-content-inventory');
        let html = '';
        
        const skillItems =[];
        this.ownedSkills.forEach(id => {
            const s = SKILLS_DB[id];
            if(s) skillItems.push({ _type: 'skill', _id: id, icon: s.icon, name: s.name, desc: s.desc });
        });
        
        const passiveItems =[];
        this.ownedPassives.forEach(id => {
            const p = REWARD_POOL.find(x => x.id === id);
            if(p) passiveItems.push({ _type: 'passive', _id: id, icon: p.icon, name: p.name, desc: p.desc });
        });
        
        // Skills Render
        html += `<div style="color: var(--rare); margin-bottom: 10px; font-weight: bold; padding-bottom:5px; border-bottom:1px solid rgba(255,255,255,0.1);">æŠ€èƒ½é“å…·</div>`;
        html += '<div class="inv-grid">';
        if (skillItems.length === 0) {
            html += `<div style="grid-column: 1/-1; text-align: center; color: #666; padding: 10px;">æš‚æ— æŠ€èƒ½é“å…·</div>`;
        } else {
            skillItems.forEach(item => {
                const isEquip = this.equippedSkills.includes(item._id);
                const equipCls = isEquip ? 'equipped' : '';
                
                let countBadge = '';
                if (SKILLS_DB[item._id] && SKILLS_DB[item._id].type === 'consumable') {
                    countBadge = `<div style="position:absolute; bottom:-5px; right:-5px; background:#000; color:#fff; font-size:10px; padding:2px 4px; border:1px solid var(--rare); border-radius:4px;">x${this.skillUsage[item._id] || 0}</div>`;
                }

                html += `
                <div class="inv-item ${equipCls}" onclick="game.clickInvItem('${item._type}', '${item._id}', event)">
                    <div style="font-size: 28px; margin-bottom: 5px;">${item.icon}</div>
                    <div style="font-size: 11px; font-weight: bold; color: #fff;">${item.name}</div>
                    ${countBadge}
                </div>`;
            });
        }
        html += '</div>';

        // Passives Render
        html += `<div style="color: var(--highlight); margin-bottom: 10px; margin-top: 10px; font-weight: bold; padding-bottom:5px; border-bottom:1px solid rgba(255,255,255,0.1);">æ™®é€šé“å…·</div>`;
        html += '<div class="inv-grid">';
        if (passiveItems.length === 0) {
            html += `<div style="grid-column: 1/-1; text-align: center; color: #666; padding: 10px;">æš‚æ— æ™®é€šé“å…·</div>`;
        } else {
            passiveItems.forEach(item => {
                const isEquip = this.equippedPassives.includes(item._id);
                const equipCls = isEquip ? 'equipped' : '';

                html += `
                <div class="inv-item ${equipCls}" onclick="game.clickInvItem('${item._type}', '${item._id}', event)">
                    <div style="font-size: 28px; margin-bottom: 5px;">${item.icon}</div>
                    <div style="font-size: 11px; font-weight: bold; color: #fff;">${item.name}</div>
                </div>`;
            });
        }
        html += '</div>';

        ct.innerHTML = html;
    }

    clickEquipSlot(type, index, e) {
        e.stopPropagation();
        let itemId = type === 'skill' ? this.equippedSkills[index] : this.equippedPassives[index];
        if (!itemId) return; 
        
        let name = '', desc = '';
        if (type === 'skill') {
            const s = SKILLS_DB[itemId];
            name = s.name; desc = s.desc;
        } else {
            const p = REWARD_POOL.find(x => x.id === itemId);
            name = p.name; desc = p.desc;
        }
        
        this.showInteractBubble(e.clientX, e.clientY, name, desc, 'å¸ä¸‹', () => {
            if (type === 'skill') this.equippedSkills.splice(index, 1);
            else this.equippedPassives.splice(index, 1);
            
            this.renderEquipCircle();
            if (document.getElementById('tab-content-inventory').style.display === 'block') {
                this.renderInventory();
            }
            document.getElementById('item-interact-bubble').style.display = 'none';
        });
    }

    clickInvItem(type, id, e) {
        e.stopPropagation();
        let name = '', desc = '';
        if (type === 'skill') {
            const s = SKILLS_DB[id]; name = s.name; desc = s.desc;
        } else {
            const p = REWARD_POOL.find(x => x.id === id); name = p.name; desc = p.desc;
        }
        
        const isEquipped = (type === 'skill' && this.equippedSkills.includes(id)) || 
                           (type === 'passive' && this.equippedPassives.includes(id));
        
        if (isEquipped) {
            this.showInteractBubble(e.clientX, e.clientY, name, desc, 'å¸ä¸‹', () => {
                if (type === 'skill') {
                    const idx = this.equippedSkills.indexOf(id);
                    if(idx > -1) this.equippedSkills.splice(idx, 1);
                } else {
                    const idx = this.equippedPassives.indexOf(id);
                    if(idx > -1) this.equippedPassives.splice(idx, 1);
                }
                
                this.renderEquipCircle();
                this.renderInventory();
                document.getElementById('item-interact-bubble').style.display = 'none';
            });
        } else {
            const canEquip = (type === 'skill' && this.equippedSkills.length < this.maxSkillSlots) || 
                             (type === 'passive' && this.equippedPassives.length < this.maxPassiveSlots);
            
            this.showInteractBubble(e.clientX, e.clientY, name, desc, 'è£…å¤‡', () => {
                if (type === 'skill') this.equippedSkills.push(id);
                else this.equippedPassives.push(id);
                
                this.renderEquipCircle();
                this.renderInventory();
                document.getElementById('item-interact-bubble').style.display = 'none';
            }, !canEquip);
        }
    }

    showInteractBubble(x, y, name, desc, btnText, onClick, disableBtn = false) {
        const bubble = document.getElementById('item-interact-bubble');
        document.getElementById('interact-name').innerText = name;
        document.getElementById('interact-desc').innerText = desc;
        const btn = document.getElementById('interact-btn');
        btn.innerText = btnText;
        btn.disabled = disableBtn;
        btn.className = disableBtn ? 'btn' : (btnText === 'å¸ä¸‹' ? 'btn' : 'btn btn-primary');
        if (btnText === 'å¸ä¸‹') btn.style.border = '1px solid #e74c3c';
        else btn.style.border = '';
        
        btn.onclick = onClick;
        
        bubble.style.display = 'block';
        let bw = 220, bh = bubble.offsetHeight || 150;
        let finalX = x + 15;
        let finalY = y + 15;
        if (finalX + bw > window.innerWidth) finalX = x - bw - 15;
        if (finalY + bh > window.innerHeight) finalY = y - bh - 15;
        
        bubble.style.left = finalX + 'px';
        bubble.style.top = finalY + 'px';
    }

    leaveShop() {
        document.getElementById('item-interact-bubble').style.display = 'none';
        document.getElementById('shop-screen').style.display = 'none';
        this.setOverlayState(false);
        this.levelIndex++; 
        this.showMap(); 
    }

    nextLevelAction() { 
        document.getElementById('overlay-screen').classList.remove('visible'); 
        this.setOverlayState(false);
        this.levelIndex++; 
        this.startLevel(); 
    }
    nextRound() { 
        document.getElementById('overlay-screen').classList.remove('visible'); 
        this.setOverlayState(false);
        this.currentRound++; 
        this.startRound(); 
    }

    activateSkill(k) { this.skillMode = k; this.selectedCards=[]; this.selectedOppCard = null; this.updateControls(); this.renderScene(); }
    cancelSkill() { this.skillMode=null; this.selectedCards=[]; this.selectedOppCard = null; this.updateControls(); this.renderScene(); }
    
    executeSkill() {
        const draw = (n) => { const c =[]; 
            if (this.drawPile.length < n) {
                if(this.discardPile.length > 0) {
                    this.drawPile.push(...this.discardPile);
                    this.discardPile =[];
                    this.shuffle(this.drawPile);
                } else {
                    let fresh = this.createDeck();
                    this.drawPile.push(...fresh);
                }
            }
            for(let i=0;i<n;i++) if(this.drawPile.length>0) c.push(this.drawPile.pop()); 
            return c; 
        };

        if(this.skillMode==='xuanji') {
            const n=this.selectedCards.length; const nc=draw(n); const selIds = this.selectedCards.map(c=>c.id);
            this.playerHand=this.playerHand.filter(x => !selIds.includes(x.id)); for(let c of nc) this.playerHand.push(c); 
            this.playerHand.sort((a,b)=>b.value-a.value); this.skillUsage.xuanji--;
            
            this.discardPile.push(...this.selectedCards);
            this.selectedCards =[...nc]; 
            this.renderScene();
            setTimeout(() => { this.selectedCards =[]; this.renderScene(); }, 2000);

        } else if(this.skillMode==='yundu') {
            const m = this.selectedCards[0]; const r = Math.floor(Math.random() * this.oppHand.length); const t = this.oppHand[r];
            if(m && t) { 
                const pIdx = this.playerHand.findIndex(c => c.id === m.id); 
                if(pIdx > -1) { 
                    this.playerHand[pIdx] = t; this.oppHand[r] = m; 
                    
                    if (this.config.openHand || this.oppHand.some(c => c.revealed)) {
                        m.revealed = true;
                    } else {
                        m.revealed = false;
                    }

                    this.playerHand.sort((a,b)=>b.value-a.value); 
                    this.skillUsage.yundu--; 
                    
                    this.selectedCards =[t];
                    this.renderScene();
                    setTimeout(() => { this.selectedCards =[]; this.renderScene(); }, 2000);
                } 
            }
        } else if (this.skillMode==='blast') {
            const mine = this.selectedCards[0]; const theirs = this.selectedOppCard;
            if(mine && theirs) { 
                const myIdx = this.playerHand.findIndex(c => c.id === mine.id); const oppIdx = this.oppHand.findIndex(c => c.id === theirs.id); 
                if (myIdx > -1 && oppIdx > -1) { 
                    this.playerHand[myIdx] = theirs; this.oppHand[oppIdx] = mine; 
                    
                    if (this.config.openHand || this.oppHand.some(c => c.revealed)) {
                        mine.revealed = true;
                    } else {
                        mine.revealed = false;
                    }

                    this.playerHand.sort((a,b)=>b.value-a.value); 
                    this.skillUsage.blast--; 

                    this.selectedCards =[theirs];
                    this.renderScene();
                    setTimeout(() => { this.selectedCards =[]; this.renderScene(); }, 2000);
                } 
            }
        } else if (this.skillMode==='xinjing') {
            if(this.oppBait.length === 0) { const sort =[...this.oppHand].sort((a,b)=>a.value-b.value); this.oppBait = [sort[0], sort[1]]; this.oppHand = sort.slice(2); }
            this.oppBait.forEach(c => c.revealed = true); this.skillUsage.xinjing--; this.renderScene();
            this.cancelSkill();
        } else if (this.skillMode==='abyss') {
            this.oppHand.forEach(c => c.revealed = true); this.skillUsage.abyss--;
            this.cancelSkill();
        } else if (this.skillMode==='mirror') {
            this.playerHand = this.oppHand.map(c => new Card(c.suit, c.rank)); this.skillUsage.mirror--;
            this.cancelSkill();
        }
        
        if (['xuanji','yundu','blast', 'xinjing', 'abyss', 'mirror'].includes(this.skillMode)) {
            if (SKILLS_DB[this.skillMode] && SKILLS_DB[this.skillMode].type === 'consumable') {
                if (this.skillUsage[this.skillMode] <= 0) {
                    this.ownedSkills = this.ownedSkills.filter(s => s !== this.skillMode);
                    this.equippedSkills = this.equippedSkills.filter(s => s !== this.skillMode);
                    delete this.skillUsage[this.skillMode];
                }
            }
            
            this.skillMode = null; 
            this.selectedOppCard = null;
            this.updateControls();
            this.renderScene();
        } else {
            this.cancelSkill();
        }
    }
    placeBet(idx) { const p = this.betRatios[idx]; const a=Math.floor(this.playerGold*p); this.playerGold-=a; this.currentBet+=a; this.betUsedThisRound = true; this.cancelSkill(); this.updateHeader(); }
    updateHeader() {
        document.getElementById('level-id').innerText = `FLOOR ${this.config.id}`;
        document.getElementById('gold-display').innerText = this.playerGold;
        const betDis = document.getElementById('bet-display');
        if(this.currentBet > 0) { betDis.style.display='block'; betDis.innerText = `ä¸‹æ³¨: ${this.currentBet}`; } else { betDis.style.display='none'; }
        const pl = document.getElementById('passive-list'); pl.innerHTML = '';
        this.equippedPassives.forEach(pId => { 
            const p = REWARD_POOL.find(x => x.id === pId);
            if(p) {
                const d = document.createElement('div'); d.className = 'passive-icon'; d.setAttribute('data-desc', `${p.name || ''}: ${p.desc}`); d.innerHTML = p.icon; pl.appendChild(d); 
            }
        });
        
        const g = document.getElementById('level-desc');
        if (this.config.target === 'best_of_3') {
             g.innerHTML = `3å±€2èƒœ (<span class="gold-val">${this.currentLevelWins}èƒœ/${this.currentLevelLosses}è´Ÿ</span>) - ç¬¬${this.currentRound}/3å›åˆ <span style="font-size:10px; color:#aaa; margin-left:5px;">ç‰Œå‹èµ¢è¿‡å¯¹æ–¹å³èƒœ</span>`;
        } else {
             g.innerHTML = `3å›åˆå†…ç§¯åˆ† â‰¥ <span class="gold-val">${Math.floor(this.levelEarnedGold)}/${this.currentTargetGold}</span> (${this.currentRound}/3å›åˆ)`;
        }
    }
    toggleInfo() {
        const sc = document.getElementById('info-screen');
        if(sc.classList.contains('visible')) { 
            sc.classList.remove('visible'); 
            this.setOverlayState(false);
            return; 
        }
        
        this.setOverlayState(true);
        const ct = document.getElementById('info-content'); ct.innerHTML = '';
        
        const isDefault = !this.inGame; 

        HAND_TYPES_BASE.forEach(t => {
            let val = t.base; let act = false; let mult = 0;
            
            if (!isDefault) {
                this.equippedPassives.forEach(pId=>{ 
                    const p = REWARD_POOL.find(x => x.id === pId);
                    if(p && p.trigger===t.name) { 
                        if (p.val) { val += p.val; act=true; }
                        if (p.mult) { mult+=p.mult; } 
                    } 
                });
            }

            ct.innerHTML += `<div class="info-row"><span>${t.name} <span style="font-size:10px; color:#666">(${t.en})</span></span><span style="${act?'color:var(--gold-color)':''}">${val}ç§¯åˆ†${act?'â†‘':''}</span><span style="${mult>0?'color:var(--rare)':''}">æŠ€èƒ½å€æ•°ï¼š${mult}</span></div>`;
        });
        sc.classList.add('visible');
    }
}
const game = new Game();
</script>
</body>
</html>